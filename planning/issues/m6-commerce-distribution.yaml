milestone: M6 - Commerce & Distribution
task_count: 17
issues:
- key: T74
  title: Discord Bot
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 5
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: "**Context:**\nDiscord bot is needed for community engagement\
      \ and content distribution in the M6 Commerce milestone. It enables automated\
      \ notifications for new comic releases, user achievements, and community features\
      \ like sharing comic panels. This creates a direct marketing channel to engaged\
      \ users and builds community around the Morpheus platform. Given Discord's popularity\
      \ with comic/gaming communities, this provides organic growth opportunities.\n\
      \n**Technical Approach:**\nBuild using discord.js v14 with TypeScript, deployed\
      \ as a separate service within the Turborepo structure. Implement slash commands\
      \ for comic browsing, webhook integrations for release notifications, and OAuth\
      \ flow for account linking. Use Supabase for storing Discord user mappings and\
      \ preferences. Deploy on same infrastructure as other services with proper environment\
      \ separation.\n\n**AI Suitability Analysis:**\n- High AI effectiveness: Command\
      \ handlers, event listeners, webhook endpoints, Discord API integration boilerplate,\
      \ slash command definitions, basic CRUD operations for user preferences\n- Medium\
      \ AI effectiveness: OAuth flow implementation, message formatting/embeds, error\
      \ handling middleware, integration with existing Morpheus APIs\n- Low AI effectiveness:\
      \ Bot permission strategy, community moderation logic, business rules for notifications,\
      \ Discord server setup/configuration\n\n**Dependencies:**\n- External: discord.js\
      \ v14, @discordjs/builders, @discordjs/rest\n- Internal: Shared types package,\
      \ Supabase client, authentication utilities from backend service\n- Platform:\
      \ Discord Developer Portal app, bot tokens, webhook URLs\n\n**Risks:**\n- Rate\
      \ limiting: Discord has strict rate limits - implement proper queuing and backoff\n\
      - Token security: Bot tokens need secure storage and rotation strategy  \n-\
      \ Scope creep: Discord bots can become feature-heavy - define clear MVP boundaries\n\
      - Moderation complexity: Community management features add significant complexity\n\
      - API changes: Discord.js v14 has breaking changes from v13, maintain version\
      \ compatibility\n\n**Complexity Notes:**\nMedium complexity task. Discord.js\
      \ provides good abstractions but proper error handling, rate limiting, and OAuth\
      \ integration add complexity. AI can handle 70% of boilerplate but human decisions\
      \ needed for UX flow and community features. Estimate 2-3 sprints for MVP.\n\
      \n**Key Files:**\n- apps/discord-bot/: New application directory\n- packages/shared/src/types/discord.ts:\
      \ Discord-specific types\n- packages/database/src/tables/discord-users.sql:\
      \ User mapping table\n- apps/backend/src/webhooks/discord.ts: Webhook handlers\
      \ for notifications\n"
    design_decisions:
    - decision: Separate Discord bot service vs integrated backend module
      rationale: Discord bots benefit from dedicated process for WebSocket connections,
        easier scaling, and cleaner separation of concerns
      alternatives_considered:
      - Backend module
      - Serverless functions
      - Third-party bot platform
      ai_implementation_note: AI can generate entire bot service structure, command
        handlers, and event listeners with proper prompting
    - decision: Slash commands over message prefix commands
      rationale: Discord's modern approach, better UX, built-in validation, and auto-discovery.
        Aligns with Discord's recommended practices
      alternatives_considered:
      - Prefix commands
      - Hybrid approach
      - Context menus only
      ai_implementation_note: AI excels at generating slash command builders and interaction
        handlers from specification
    - decision: OAuth integration for account linking
      rationale: Enables personalized experiences, purchase notifications, and progress
        tracking. Required for commerce integration
      alternatives_considered:
      - Manual username linking
      - No account linking
      - Discord ID only
      ai_implementation_note: AI can implement OAuth flow but human review needed
        for security and token handling
    researched_at: '2026-02-08T18:48:54.985900'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:31:53.878204'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: a8111c16
    planning_hash: 30b1133f
  technical_notes:
    approach: 'Create new Turborepo app ''discord-bot'' using discord.js v14 with
      TypeScript. Implement slash commands for comic browsing, webhook endpoints for
      release notifications, and OAuth flow for Morpheus account linking. Use Supabase
      for Discord user preferences and mapping. Deploy as containerized service alongside
      existing infrastructure with proper rate limiting and error handling.

      '
    external_dependencies:
    - name: discord.js
      version: ^14.14.1
      reason: Primary Discord API wrapper with TypeScript support
    - name: '@discordjs/builders'
      version: ^1.7.0
      reason: Utilities for building slash commands and embeds
    - name: '@discordjs/rest'
      version: ^2.2.0
      reason: REST API client with built-in rate limiting
    files_to_modify:
    - path: apps/backend/src/webhooks/index.ts
      changes: Add Discord webhook endpoint registration
    - path: packages/shared/src/types/index.ts
      changes: Export Discord-specific types for cross-app usage
    - path: packages/database/migrations/20240115_discord_users.sql
      changes: Add migration for discord_users table
    new_files:
    - path: apps/discord-bot/package.json
      purpose: Discord bot app dependencies and scripts
    - path: apps/discord-bot/src/index.ts
      purpose: Bot entry point and client initialization
    - path: apps/discord-bot/src/commands/comics.ts
      purpose: Slash command handler for comic browsing
    - path: apps/discord-bot/src/commands/profile.ts
      purpose: User profile and preferences management
    - path: apps/discord-bot/src/commands/link-account.ts
      purpose: OAuth flow initiation for account linking
    - path: apps/discord-bot/src/services/discord-api.ts
      purpose: Discord API wrapper with rate limiting and error handling
    - path: apps/discord-bot/src/services/oauth.ts
      purpose: OAuth flow management and token handling
    - path: apps/discord-bot/src/webhooks/notifications.ts
      purpose: Webhook handlers for incoming notifications from backend
    - path: apps/discord-bot/src/utils/embed-builder.ts
      purpose: Message embed formatting utilities
    - path: apps/discord-bot/src/middleware/rate-limiter.ts
      purpose: Rate limiting middleware for Discord API calls
    - path: packages/shared/src/types/discord.ts
      purpose: Discord-specific TypeScript interfaces and types
    - path: packages/database/src/tables/discord-users.sql
      purpose: Discord user mapping and preferences table schema
    - path: apps/backend/src/webhooks/discord.ts
      purpose: Backend webhook handlers for Discord notifications
    - path: apps/discord-bot/Dockerfile
      purpose: Container configuration for Discord bot deployment
    - path: apps/discord-bot/src/config/environment.ts
      purpose: Environment configuration and validation
  acceptance_criteria:
  - criterion: Discord bot can register and respond to slash commands (/comics, /profile,
      /link-account)
    verification: Test commands in Discord server return proper responses with comic
      data or user info
  - criterion: Bot sends automated notifications for new comic releases via webhooks
    verification: Create test comic release, verify notification posted to configured
      Discord channel within 30 seconds
  - criterion: OAuth flow successfully links Discord accounts to Morpheus user profiles
    verification: Complete OAuth flow, verify discord_users table contains mapping
      and user can access personalized features
  - criterion: Bot handles rate limiting gracefully without service disruption
    verification: Load test with 100+ concurrent commands, verify no failed requests
      and proper queuing behavior
  - criterion: All bot interactions are logged and errors are properly handled
    verification: Check logs for command usage, verify error responses don't expose
      sensitive data
  testing:
    unit_tests:
    - file: apps/discord-bot/src/__tests__/commands/comics.test.ts
      coverage_target: 90%
      scenarios:
      - Comics list command returns formatted embed
      - Invalid comic ID returns error message
      - User with no linked account gets link prompt
    - file: apps/discord-bot/src/__tests__/services/discord-api.test.ts
      coverage_target: 85%
      scenarios:
      - Rate limiting queue functions correctly
      - Webhook delivery with retry logic
      - OAuth token exchange validation
    integration_tests:
    - file: apps/discord-bot/src/__tests__/integration/bot-commands.test.ts
      scenarios:
      - End-to-end slash command execution with database queries
      - Webhook notification flow from backend to Discord
      - Complete OAuth linking flow
    manual_testing:
    - step: Deploy bot to test Discord server and execute /comics command
      expected: Returns embed with comic list and thumbnail images
    - step: Trigger webhook from backend service for new comic release
      expected: Bot posts notification to configured channel with comic details
    - step: Complete OAuth flow through /link-account command
      expected: User receives success message and can access personalized features
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Setup Discord bot application structure in Turborepo with package.json
        and basic TypeScript config'
      done: false
      ai_friendly: true
    - task: '[AI] Generate Discord types and interfaces in packages/shared/src/types/discord.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Create database migration for discord_users table with proper foreign
        key relationships'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure Discord Developer Portal app, obtain bot tokens, and
        define permission strategy'
      done: false
      ai_friendly: false
    - task: '[AI] Implement bot client initialization and slash command registration
        system'
      done: false
      ai_friendly: true
    - task: '[AI] Create command handlers for /comics, /profile, and /link-account
        with proper error handling'
      done: false
      ai_friendly: true
    - task: '[AI] Build OAuth service for Discord-Morpheus account linking with token
        management'
      done: false
      ai_friendly: true
    - task: '[AI] Implement webhook endpoints and notification handlers for comic
        releases'
      done: false
      ai_friendly: true
    - task: '[AI] Add rate limiting middleware and Discord API wrapper with retry
        logic'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Define notification business rules and community moderation policies'
      done: false
      ai_friendly: false
    - task: '[AI] Write comprehensive unit and integration tests for all components'
      done: false
      ai_friendly: true
    - task: '[AI] Create Docker configuration and deployment scripts'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Review security implementation, test OAuth flow, and validate
        rate limiting'
      done: false
      ai_friendly: false
- key: T75
  title: Discord Command Handler
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 3
  area: distribution
  dependsOn:
  - T74
  agent_notes:
    research_findings: "**Context:**\nDiscord Command Handler is needed to enable\
      \ distribution and community engagement for Morpheus comics through Discord\
      \ bots. This allows users to discover, preview, and potentially purchase comics\
      \ directly within Discord servers, expanding the platform's reach beyond the\
      \ web storefront. Given the M6 milestone focus on commerce & distribution, this\
      \ likely includes payment integration, user authentication, and content delivery\
      \ through Discord interactions.\n\n**Technical Approach:**\n- Use discord.js\
      \ v14 for robust Discord API integration\n- Implement slash command architecture\
      \ for modern Discord UX\n- Create command registry system with TypeScript decorators\
      \ for clean organization\n- Integrate with existing Morpheus backend APIs via\
      \ HTTP clients\n- Use Discord OAuth2 for user authentication and linking to\
      \ Morpheus accounts\n- Implement webhook handling for Discord events\n- Deploy\
      \ as separate microservice that can scale independently\n- Use Redis for command\
      \ cooldowns and session management\n\n**AI Suitability Analysis:**\n- High AI\
      \ effectiveness: Command boilerplate generation, Discord embed builders, error\
      \ handling patterns, unit tests for command logic, API client wrappers\n- Medium\
      \ AI effectiveness: Discord OAuth flow integration, webhook event handlers,\
      \ command validation middleware\n- Low AI effectiveness: Discord bot architecture\
      \ decisions, command permission strategies, rate limiting policies, user experience\
      \ design\n\n**Dependencies:**\n- External: discord.js@14.x, @discordjs/rest,\
      \ @discordjs/builders, ioredis for caching\n- Internal: Morpheus backend API\
      \ client, shared TypeScript types, authentication service integration, Supabase\
      \ client for user linking\n\n**Risks:**\n- Discord rate limiting: Implement\
      \ proper queuing and respect API limits\n- Bot token security: Use environment\
      \ variables and rotation strategies  \n- Command spam: Implement cooldowns and\
      \ user-level rate limiting\n- Service coupling: Keep Discord service loosely\
      \ coupled from main backend\n- Scale issues: Bot presence limits may require\
      \ verification for large servers\n\n**Complexity Notes:**\nMore complex than\
      \ initially estimated due to Discord's interaction model requiring stateful\
      \ session management and OAuth integration. However, AI can significantly accelerate\
      \ development of command handlers and Discord API boilerplate, potentially offsetting\
      \ complexity.\n\n**Key Files:**\n- packages/discord-bot/: New service package\n\
      - packages/discord-bot/src/commands/: Command handler implementations\n- packages/discord-bot/src/handlers/:\
      \ Event and interaction handlers\n- packages/shared/types/: Discord-specific\
      \ type definitions\n- packages/backend/src/routes/discord/: Backend endpoints\
      \ for Discord integration\n"
    design_decisions:
    - decision: Separate Discord bot as independent microservice
      rationale: Isolates Discord-specific logic, enables independent scaling, and
        prevents Discord downtime from affecting main platform
      alternatives_considered:
      - Integrate into main backend
      - Serverless functions for commands
      ai_implementation_note: AI can generate service boilerplate, Docker configs,
        and deployment scripts once architecture is defined
    - decision: Use slash commands over message parsing
      rationale: Modern Discord UX standard, better discoverability, built-in validation,
        and official Discord recommendation
      alternatives_considered:
      - Prefix-based commands
      - Hybrid approach
      ai_implementation_note: AI excels at generating slash command builders and interaction
        response handlers
    - decision: Redis for session and cooldown management
      rationale: Fast lookups needed for real-time Discord interactions, shared state
        across bot instances
      alternatives_considered:
      - In-memory storage
      - PostgreSQL only
      ai_implementation_note: AI can generate Redis client patterns and caching strategies
        effectively
    researched_at: '2026-02-08T18:49:20.300528'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:32:19.405039'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 2bcfae29
    planning_hash: 41903e58
  technical_notes:
    approach: 'Create a standalone Discord bot service using discord.js with slash
      command architecture. Implement OAuth2 flow to link Discord users to Morpheus
      accounts. Build command handlers for comic discovery, previews, and purchase
      flows that communicate with the main Morpheus backend via REST APIs. Use Redis
      for session management and rate limiting, with proper error handling and logging
      throughout.

      '
    external_dependencies:
    - name: discord.js
      version: ^14.14.1
      reason: Primary Discord API client library with TypeScript support
    - name: '@discordjs/builders'
      version: ^1.7.0
      reason: Utilities for building Discord API payloads and slash commands
    - name: '@discordjs/rest'
      version: ^2.2.0
      reason: Standalone REST client for Discord API interactions
    - name: ioredis
      version: ^5.3.2
      reason: Redis client for session management and rate limiting
    files_to_modify:
    - path: packages/backend/src/routes/auth/discord.ts
      changes: Add OAuth2 callback endpoints for Discord integration
    - path: packages/backend/src/services/userService.ts
      changes: Add methods for linking Discord accounts to user profiles
    - path: packages/shared/src/types/user.ts
      changes: Add Discord account linking fields to user type
    - path: docker-compose.yml
      changes: Add discord-bot service configuration
    - path: packages/backend/prisma/schema.prisma
      changes: Add discord_user_id field to User model
    new_files:
    - path: packages/discord-bot/package.json
      purpose: Discord bot service package configuration
    - path: packages/discord-bot/src/bot.ts
      purpose: Main bot entry point and Discord client setup
    - path: packages/discord-bot/src/commands/comics.ts
      purpose: Comic discovery and preview slash commands
    - path: packages/discord-bot/src/commands/auth.ts
      purpose: User authentication and account linking commands
    - path: packages/discord-bot/src/handlers/interactionHandler.ts
      purpose: Discord interaction event processing
    - path: packages/discord-bot/src/handlers/oauthHandler.ts
      purpose: OAuth2 callback and token management
    - path: packages/discord-bot/src/services/morpheusAPI.ts
      purpose: HTTP client for Morpheus backend integration
    - path: packages/discord-bot/src/services/redisService.ts
      purpose: Session management and rate limiting cache
    - path: packages/discord-bot/src/middleware/rateLimit.ts
      purpose: Command cooldown and rate limiting logic
    - path: packages/discord-bot/src/utils/embedBuilder.ts
      purpose: Discord embed creation utilities
    - path: packages/discord-bot/src/types/discord.ts
      purpose: Discord-specific TypeScript type definitions
    - path: packages/discord-bot/Dockerfile
      purpose: Container configuration for bot deployment
  acceptance_criteria:
  - criterion: Discord bot responds to slash commands for comic discovery (/comics
      list, /comics search, /comics preview)
    verification: Test slash commands in Discord server return proper embeds with
      comic data from Morpheus API
  - criterion: OAuth2 flow successfully links Discord users to Morpheus accounts
    verification: User can authenticate via /login command and subsequent commands
      show personalized data
  - criterion: Bot handles rate limiting and cooldowns properly
    verification: Commands respect 5-second user cooldowns and Discord API rate limits
      without errors
  - criterion: Error handling provides user-friendly messages for all failure scenarios
    verification: Test API failures, invalid inputs, and permission errors return
      helpful Discord embeds
  - criterion: Bot integrates with existing Morpheus backend for comic data and user
      management
    verification: Commands fetch real data from staging/production Morpheus API endpoints
  testing:
    unit_tests:
    - file: packages/discord-bot/src/__tests__/commands/comics.test.ts
      coverage_target: 90%
      scenarios:
      - Comics list command with valid pagination
      - Search command with filters
      - Preview command with valid comic ID
      - Error handling for invalid comic IDs
      - Rate limiting enforcement
    - file: packages/discord-bot/src/__tests__/handlers/oauth.test.ts
      coverage_target: 85%
      scenarios:
      - Successful OAuth2 flow completion
      - Invalid state parameter handling
      - Token refresh logic
      - User account linking/unlinking
    integration_tests:
    - file: packages/discord-bot/src/__tests__/integration/bot.test.ts
      scenarios:
      - Full command execution flow with mock Discord client
      - Backend API integration with test endpoints
      - Redis session management
    manual_testing:
    - step: Deploy bot to test Discord server and run /comics list
      expected: Returns paginated embed with comic thumbnails and titles
    - step: Execute OAuth flow via /login command
      expected: User receives DM with auth link and successful account linking
    - step: Test rate limiting by spamming commands
      expected: Bot responds with cooldown messages after limit exceeded
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create Discord bot package structure and basic configuration files'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design command permission strategy and bot architecture decisions'
      done: false
      ai_friendly: false
    - task: '[AI] Implement discord.js client setup with slash command registration'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comic discovery commands (/comics list, search, preview)'
      done: false
      ai_friendly: true
    - task: '[AI] Build Discord embed utilities and error handling patterns'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure OAuth2 flow and security considerations'
      done: false
      ai_friendly: false
    - task: '[AI] Implement rate limiting middleware and Redis integration'
      done: false
      ai_friendly: true
    - task: '[AI] Create HTTP client service for Morpheus API integration'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit tests for all command handlers'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Manual testing in Discord server and security review'
      done: false
      ai_friendly: false
    - task: '[AI] Create deployment configuration and documentation'
      done: false
      ai_friendly: true
- key: T76
  title: Reddit Integration
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p2
  effort: 3
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      Reddit integration enables Morpheus users to share their generated comics to
      relevant subreddits, driving organic discovery and user acquisition. This addresses
      the "distribution gap" where creators have amazing content but struggle to reach
      audiences. Reddit''s community-driven nature makes it perfect for niche comic
      content, webcomics, and fan fiction adaptations. The feature should support
      automated posting with proper attribution, community guidelines compliance,
      and engagement tracking.


      **Technical Approach:**

      Implement using Reddit''s OAuth 2.0 API with PRAW-like functionality in TypeScript.
      Create a dedicated Reddit service in the backend with rate limiting, queue management
      for posts, and webhook handling for engagement metrics. Frontend should provide
      Reddit account linking, subreddit selection with community size/relevance scoring,
      and post scheduling. Use Supabase for storing Reddit credentials (encrypted),
      post history, and engagement analytics. Implement proper error handling for
      Reddit API limitations and shadowban detection.


      **AI Suitability Analysis:**

      - High AI effectiveness: Reddit API client wrapper, OAuth flow boilerplate,
      database schemas for post tracking, engagement metrics aggregation, unit tests
      for API responses, form components for account linking

      - Medium AI effectiveness: Rate limiting logic, webhook processing, subreddit
      recommendation algorithm, post formatting/templating, retry mechanisms for failed
      posts

      - Low AI effectiveness: Community guidelines compliance logic, content moderation
      decisions, subreddit selection strategy, engagement optimization algorithms,
      Reddit API policy interpretation


      **Dependencies:**

      - External: snoowrap (Reddit API client), ioredis (rate limiting), node-cron
      (scheduling)

      - Internal: Authentication service (for OAuth), Content service (comic metadata),
      Analytics service (tracking), Notification service (post status updates)


      **Risks:**

      - Reddit API rate limiting (600 requests/10min): implement exponential backoff
      and request queuing

      - Account suspension/shadowbanning: build detection mechanisms and user notifications

      - Subreddit-specific rules violation: create rule checking and approval workflows

      - User privacy concerns: implement granular permission controls and clear data
      usage policies


      **Complexity Notes:**

      More complex than initially estimated due to Reddit''s strict API policies and
      community guidelines. However, AI can significantly accelerate development of
      the integration layer and testing. The main complexity lies in building robust
      error handling and compliance checking, which requires human domain expertise
      about Reddit culture and policies.


      **Key Files:**

      - packages/backend/src/services/reddit.service.ts: Core Reddit API integration

      - packages/backend/src/routes/reddit/: OAuth and webhook endpoints

      - packages/frontend/src/components/reddit/: Account linking and post management
      UI

      - packages/database/migrations/: Reddit credentials and post tracking tables

      - packages/shared/types/reddit.ts: Type definitions for Reddit entities

      '
    design_decisions:
    - decision: Use snoowrap library for Reddit API integration
      rationale: Mature, well-maintained TypeScript Reddit API client with built-in
        OAuth, rate limiting, and error handling. Reduces development time and provides
        battle-tested Reddit API abstractions.
      alternatives_considered:
      - Raw Reddit API calls with axios
      - reddit-ts library
      - Custom Reddit API wrapper
      ai_implementation_note: AI can generate comprehensive service methods, error
        handling, and type-safe API calls using snoowrap's interface
    - decision: Implement post queue with Redis for rate limiting compliance
      rationale: Reddit has strict rate limits (600 requests/10min). A queue ensures
        posts are distributed over time, prevents API violations, and provides retry
        mechanisms for failed posts.
      alternatives_considered:
      - In-memory queue
      - Database-based queue
      - Third-party queue service
      ai_implementation_note: AI can generate Redis queue operations, job processing
        logic, and retry mechanisms following established patterns
    - decision: Store encrypted Reddit credentials in Supabase with row-level security
      rationale: Leverages existing authentication system, provides granular access
        control, and ensures credentials are encrypted at rest. RLS policies prevent
        credential access across users.
      alternatives_considered:
      - Separate credential storage service
      - Encrypted environment variables
      - Third-party credential management
      ai_implementation_note: AI can generate encryption/decryption utilities, database
        schemas, and RLS policies following security best practices
    researched_at: '2026-02-08T18:49:49.438226'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:32:48.480792'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 37810f4d
    planning_hash: 0ce09fa3
  technical_notes:
    approach: 'Build a comprehensive Reddit integration service that handles OAuth
      authentication, manages posting queues with rate limiting, and tracks engagement
      metrics. Implement a user-friendly dashboard for linking Reddit accounts, selecting
      target subreddits with relevance scoring, and scheduling posts. Use webhooks
      to capture engagement data and provide analytics. Ensure compliance with Reddit''s
      API terms and community guidelines through automated checking and manual review
      workflows.

      '
    external_dependencies:
    - name: snoowrap
      version: ^1.23.0
      reason: Comprehensive Reddit API client with OAuth, rate limiting, and TypeScript
        support
    - name: ioredis
      version: ^5.3.0
      reason: Redis client for implementing post queues and rate limiting
    - name: node-cron
      version: ^3.0.0
      reason: Scheduling post publication and engagement metric collection
    - name: crypto-js
      version: ^4.2.0
      reason: Encrypting Reddit credentials before database storage
    files_to_modify:
    - path: packages/backend/src/config/database.ts
      changes: Add Reddit credentials and post tracking table configurations
    - path: packages/backend/src/middleware/auth.ts
      changes: Add Reddit OAuth token validation middleware
    - path: packages/frontend/src/pages/dashboard/index.tsx
      changes: Add Reddit integration section with account status and metrics
    - path: packages/shared/types/user.ts
      changes: Add Reddit account connection status to user profile type
    new_files:
    - path: packages/backend/src/services/reddit.service.ts
      purpose: Core Reddit API integration, OAuth, posting, rate limiting
    - path: packages/backend/src/services/reddit-queue.service.ts
      purpose: Post queue management and background processing
    - path: packages/backend/src/routes/reddit/oauth.ts
      purpose: Reddit OAuth2 authentication endpoints
    - path: packages/backend/src/routes/reddit/posts.ts
      purpose: Reddit post creation and management endpoints
    - path: packages/backend/src/routes/reddit/webhooks.ts
      purpose: Reddit webhook handlers for engagement metrics
    - path: packages/backend/src/utils/reddit-rate-limiter.ts
      purpose: Reddit-specific rate limiting with Redis backing
    - path: packages/frontend/src/components/reddit/RedditAccountLink.tsx
      purpose: Reddit account connection and OAuth flow UI
    - path: packages/frontend/src/components/reddit/RedditPostScheduler.tsx
      purpose: Interface for scheduling and managing Reddit posts
    - path: packages/frontend/src/components/reddit/RedditMetrics.tsx
      purpose: Engagement metrics dashboard for Reddit posts
    - path: packages/frontend/src/components/reddit/SubredditSelector.tsx
      purpose: Subreddit selection with relevance scoring
    - path: packages/database/migrations/20240101000001_reddit_integration.sql
      purpose: Database schema for Reddit credentials, posts, and metrics
    - path: packages/shared/types/reddit.ts
      purpose: TypeScript definitions for Reddit entities and API responses
    - path: packages/backend/src/jobs/reddit-queue-processor.ts
      purpose: Background job for processing Reddit post queue
  acceptance_criteria:
  - criterion: Users can connect their Reddit account via OAuth2 and post comics to
      selected subreddits
    verification: 'Manual test: Complete OAuth flow, select subreddit, post comic,
      verify post appears on Reddit'
  - criterion: System respects Reddit API rate limits (600 requests/10min) with queue
      management
    verification: 'Load test: Submit 100+ posts, verify exponential backoff and queuing
      behavior in logs'
  - criterion: Engagement metrics (upvotes, comments, views) are tracked and displayed
      in dashboard
    verification: 'Integration test: Post comic, simulate webhook events, verify metrics
      in UI dashboard'
  - criterion: Failed posts are retried with exponential backoff and users are notified
      of final failures
    verification: 'Unit test: Mock Reddit API failures, verify retry logic and notification
      service calls'
  - criterion: System detects potential shadowbans and warns users
    verification: 'Integration test: Mock shadowban indicators, verify detection logic
      and user notifications'
  testing:
    unit_tests:
    - file: packages/backend/src/services/__tests__/reddit.service.test.ts
      coverage_target: 90%
      scenarios:
      - OAuth token refresh flow
      - Rate limiting and queue management
      - Post formatting and submission
      - Engagement metrics processing
      - Error handling and retries
      - Shadowban detection logic
    - file: packages/backend/src/routes/reddit/__tests__/oauth.test.ts
      coverage_target: 85%
      scenarios:
      - OAuth callback handling
      - Token storage and encryption
      - Account disconnection
    - file: packages/frontend/src/components/reddit/__tests__/RedditDashboard.test.tsx
      coverage_target: 80%
      scenarios:
      - Account linking flow
      - Subreddit selection
      - Post scheduling interface
      - Engagement metrics display
    integration_tests:
    - file: packages/backend/src/__tests__/integration/reddit-flow.test.ts
      scenarios:
      - Complete OAuth to post submission flow
      - Webhook processing and metrics update
      - Rate limiting across multiple requests
      - Queue processing and failure recovery
    manual_testing:
    - step: Connect Reddit account and authorize application
      expected: OAuth flow completes, account shows as connected in dashboard
    - step: Schedule post to test subreddit with rate limiting
      expected: Post queued, processed within rate limits, appears on Reddit
    - step: Simulate Reddit API errors and network failures
      expected: Appropriate error messages, retry behavior, user notifications
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database migration for Reddit integration tables'
      done: false
      ai_friendly: true
    - task: '[AI] Implement Reddit service with OAuth2 and API client wrapper'
      done: false
      ai_friendly: true
    - task: '[AI] Build rate limiting utility with Redis queue management'
      done: false
      ai_friendly: true
    - task: '[AI] Create Reddit OAuth endpoints (authorization, callback, disconnect)'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design subreddit relevance scoring algorithm and content guidelines
        compliance'
      done: false
      ai_friendly: false
    - task: '[AI] Implement post scheduling and queue processing endpoints'
      done: false
      ai_friendly: true
    - task: '[AI] Build Reddit webhook handlers for engagement metrics'
      done: false
      ai_friendly: true
    - task: '[AI] Create frontend components for account linking and post management'
      done: false
      ai_friendly: true
    - task: '[AI] Implement engagement metrics dashboard with charts and analytics'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit tests for all Reddit services and components'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Manual testing of OAuth flow and Reddit API integration with
        real accounts'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Review Reddit API compliance and community guidelines implementation'
      done: false
      ai_friendly: false
- key: T77
  title: Browser Extension
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 5
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      A browser extension for Morpheus would enable users to discover and consume
      comic content directly within their browsing experience, potentially capturing
      web novels, fan fiction, or other text content for transformation. This serves
      the M6 Commerce & Distribution milestone by creating a new distribution channel
      and lowering friction for content discovery. The extension could allow users
      to highlight text on websites, save interesting content to their Morpheus library,
      or even trigger novel-to-comic transformations directly from web content.


      **Technical Approach:**

      Build using Manifest V3 (required for Chrome Web Store) with TypeScript. Use
      the Web Extensions API for cross-browser compatibility (Chrome, Firefox, Safari).
      Create a popup interface with React (reusing Morpheus design components), background
      service worker for API communication, and content scripts for page interaction.
      Implement secure authentication flow using Supabase Auth with PKCE. Use browser
      storage APIs for offline caching and user preferences.


      **AI Suitability Analysis:**

      - High AI effectiveness: Content script injection logic, popup UI components,
      message passing boilerplate, authentication flow implementation, storage utilities,
      basic API client setup

      - Medium AI effectiveness: Background service worker logic, cross-browser compatibility
      handling, content parsing algorithms, UI state management

      - Low AI effectiveness: Extension architecture decisions, security model design,
      user experience flow, content selection algorithms, privacy considerations


      **Dependencies:**

      - External: webextension-polyfill, @supabase/supabase-js, react (shared with
      main app), tailwindcss (design consistency)

      - Internal: Shared UI components from apps/dashboard, API types from packages/shared,
      authentication utilities, comic transformation services


      **Risks:**

      - Security concerns with content scripts: Implement strict CSP and sanitize
      all user inputs

      - Cross-browser compatibility issues: Use webextension-polyfill and test on
      all major browsers

      - Store approval process delays: Follow platform guidelines strictly, prepare
      for review cycles

      - Performance impact on host pages: Minimize content script footprint, lazy
      load features

      - Authentication complexity in extension context: Use secure token storage,
      handle expiration gracefully


      **Complexity Notes:**

      More complex than initially estimated due to browser security constraints and
      cross-platform considerations. However, AI can significantly accelerate development
      of boilerplate code, UI components, and API integration. Extension-specific
      patterns (message passing, storage, permissions) may require more human guidance
      initially but become AI-friendly once established.


      **Key Files:**

      - apps/extension/manifest.json: Extension configuration and permissions

      - apps/extension/src/popup/: React-based popup interface

      - apps/extension/src/content/: Content scripts for page interaction

      - apps/extension/src/background/: Service worker for API communication

      - apps/extension/src/shared/: Shared utilities and types

      - packages/shared/: Reusable types and utilities

      '
    design_decisions:
    - decision: Use Manifest V3 with service workers
      rationale: Required for Chrome Web Store, provides better performance and security
        model
      alternatives_considered:
      - Manifest V2 (deprecated)
      - Platform-specific implementations
      ai_implementation_note: AI can generate service worker boilerplate and event
        handlers effectively
    - decision: React popup with shared component library
      rationale: Maintains design consistency with main Morpheus app, leverages existing
        components
      alternatives_considered:
      - Vanilla JS popup
      - Vue.js
      - Web Components
      ai_implementation_note: AI excels at React component adaptation and styling
        consistency
    - decision: Supabase Auth with browser storage
      rationale: Consistent authentication with main platform, secure token management
      alternatives_considered:
      - OAuth popup flow
      - Custom authentication
      - Session cookies
      ai_implementation_note: AI can implement auth flow patterns and storage utilities
        with guidance
    researched_at: '2026-02-08T18:50:16.680503'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:33:12.199997'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: aa1b0f9b
    planning_hash: 3b31121a
  technical_notes:
    approach: 'Create a new Turborepo app at apps/extension with TypeScript and React.
      Implement a popup interface for user interaction, content scripts for webpage
      text selection, and a background service worker for API communication with the
      Morpheus backend. Use message passing between components and browser storage
      for state persistence. Package using standard web extension build tools and
      prepare for multi-platform store distribution.

      '
    external_dependencies:
    - name: webextension-polyfill
      version: ^0.10.0
      reason: Cross-browser Web Extensions API compatibility
    - name: '@supabase/supabase-js'
      version: ^2.38.0
      reason: Authentication and API communication with Morpheus backend
    - name: react
      version: ^18.0.0
      reason: UI framework for popup interface, shared with main app
    - name: tailwindcss
      version: ^3.4.0
      reason: Consistent styling with main Morpheus design system
    files_to_modify:
    - path: turbo.json
      changes: Add extension build pipeline and dev scripts
    - path: packages/shared/src/types/index.ts
      changes: Add extension-specific types for content capture
    - path: apps/dashboard/src/components/ui/index.ts
      changes: Export shared components for extension use
    new_files:
    - path: apps/extension/manifest.json
      purpose: Extension configuration, permissions, and metadata
    - path: apps/extension/src/popup/App.tsx
      purpose: Main popup interface with auth and content management
    - path: apps/extension/src/content/content-script.ts
      purpose: Inject text selection and context menu functionality
    - path: apps/extension/src/background/service-worker.ts
      purpose: Handle API communication and offline sync
    - path: apps/extension/src/shared/storage.ts
      purpose: Browser storage utilities for state persistence
    - path: apps/extension/src/shared/messaging.ts
      purpose: Type-safe message passing between extension components
    - path: apps/extension/src/shared/api-client.ts
      purpose: Supabase client configured for extension context
    - path: apps/extension/package.json
      purpose: Extension dependencies and build scripts
    - path: apps/extension/vite.config.ts
      purpose: Build configuration for extension bundling
    - path: apps/extension/src/content/styles.css
      purpose: Isolated styles for content script UI elements
  acceptance_criteria:
  - criterion: Extension installs and loads in Chrome/Firefox with popup accessible
    verification: Manual installation test and popup opens via extension icon
  - criterion: Users can authenticate with existing Morpheus accounts via extension
      popup
    verification: Login flow completes and user state persists across browser sessions
  - criterion: Content script allows text selection and capture from web pages
    verification: Highlight text on any webpage, right-click shows 'Save to Morpheus'
      option
  - criterion: Selected content syncs to user's Morpheus library via API
    verification: Text captured in extension appears in apps/dashboard library within
      5 seconds
  - criterion: Extension works offline with graceful degradation
    verification: Capture text while offline, syncs when connection restored
  testing:
    unit_tests:
    - file: apps/extension/src/__tests__/popup/auth.test.ts
      coverage_target: 85%
      scenarios:
      - Successful login flow with valid credentials
      - Token refresh handling
      - Logout clears stored state
    - file: apps/extension/src/__tests__/content/text-selection.test.ts
      coverage_target: 80%
      scenarios:
      - Text selection detection
      - Context menu integration
      - Content sanitization
    - file: apps/extension/src/__tests__/background/api-client.test.ts
      coverage_target: 90%
      scenarios:
      - API request handling with auth
      - Offline queue management
      - Error retry logic
    integration_tests:
    - file: apps/extension/src/__tests__/integration/content-capture-flow.test.ts
      scenarios:
      - End-to-end text capture to library sync
      - Cross-component message passing
    manual_testing:
    - step: Install extension in Chrome and Firefox
      expected: Extension appears in toolbar, no console errors
    - step: Test on complex web pages (news sites, blogs)
      expected: Text selection works without breaking page functionality
    - step: Test authentication across browser restarts
      expected: User remains logged in, tokens refresh automatically
  estimates:
    development: 5
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 8
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Setup extension project structure and package.json'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design extension architecture and message passing patterns'
      done: false
      ai_friendly: false
    - task: '[AI] Create manifest.json with required permissions'
      done: false
      ai_friendly: true
    - task: '[AI] Implement browser storage utilities and messaging layer'
      done: false
      ai_friendly: true
    - task: '[AI] Build popup React components using shared UI library'
      done: false
      ai_friendly: true
    - task: '[AI] Create Supabase auth integration for extension context'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Implement content script text selection UX'
      done: false
      ai_friendly: false
    - task: '[AI] Build background service worker API communication'
      done: false
      ai_friendly: true
    - task: '[AI] Create offline sync and queue management'
      done: false
      ai_friendly: true
    - task: '[AI] Write unit tests for all components'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Cross-browser compatibility testing and fixes'
      done: false
      ai_friendly: false
    - task: '[AI] Generate extension store listings and documentation'
      done: false
      ai_friendly: true
- key: T78
  title: Extension Comics Viewer
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 3
  area: distribution
  dependsOn:
  - T77
  agent_notes:
    research_findings: '**Context:**

      Extension Comics Viewer is needed to provide a seamless reading experience for
      users who want to read comics directly in their browser through a browser extension.
      This addresses the distribution challenge of making Morpheus-generated comics
      accessible without requiring users to visit the main platform. It''s particularly
      valuable for subscription users who want quick access to their comic library
      and new releases. This task is critical for M6 Commerce & Distribution as it
      creates a new touchpoint for user engagement and potential revenue through premium
      extension features.


      **Technical Approach:**

      Build a Manifest V3 browser extension with React components for the popup/sidebar
      viewer. Use Chrome Extension APIs for storage and tab management. Implement
      a lightweight comic reader with panel navigation, zoom controls, and offline
      reading capabilities. Connect to Morpheus backend via API for authentication
      and comic fetching. Use IndexedDB for local comic caching and reading progress
      sync.


      **AI Suitability Analysis:**

      - High AI effectiveness: Extension boilerplate (manifest.json, background scripts),
      React comic viewer components, API integration code, local storage utilities,
      basic UI layouts and styling

      - Medium AI effectiveness: Chrome Extension API integrations, authentication
      flow implementation, comic rendering optimizations, sync logic between extension
      and backend

      - Low AI effectiveness: Extension architecture decisions, security model design,
      performance optimization strategies, UX flow design for constrained popup space


      **Dependencies:**

      - External: @types/chrome for extension APIs, react-zoom-pan-pinch for comic
      navigation, idb for IndexedDB wrapper, webext-polyfill for cross-browser compatibility

      - Internal: Shared authentication utilities from packages/auth, API client from
      backend, comic metadata types from packages/types, design system components
      adapted for extension constraints


      **Risks:**

      - Browser security restrictions: Mitigation through proper CSP configuration
      and secure API communication

      - Performance with large comic files: Implement progressive loading and image
      optimization

      - Cross-browser compatibility issues: Use webext-polyfill and test across Chrome/Firefox/Safari

      - Extension store approval delays: Follow platform guidelines strictly and prepare
      for review cycles


      **Complexity Notes:**

      More complex than initially estimated due to browser extension security model
      and need for offline functionality. However, AI can significantly accelerate
      development of the React components and API integration code. The main complexity
      lies in architecting the data sync and caching strategy, which requires human
      design decisions.


      **Key Files:**

      - apps/browser-extension/: New app directory for extension

      - apps/browser-extension/manifest.json: Extension configuration

      - apps/browser-extension/src/popup/: Popup UI components

      - apps/browser-extension/src/background/: Service worker scripts

      - apps/browser-extension/src/content/: Content script for web page integration

      - packages/extension-api/: Shared API client for extension

      - apps/backend/src/routes/extension/: Backend routes for extension API

      '
    design_decisions:
    - decision: Manifest V3 Chrome Extension with React popup interface
      rationale: Manifest V3 is required for new extensions, React provides component
        reusability with existing codebase, popup interface works well for quick comic
        access
      alternatives_considered:
      - Manifest V2 (deprecated)
      - Vanilla JS UI
      - Full-page extension app
      ai_implementation_note: AI can generate most of the React components and Chrome
        API integration boilerplate once architecture is defined
    - decision: IndexedDB for local comic storage with background sync
      rationale: IndexedDB provides sufficient storage for comic images, background
        sync ensures offline availability, integrates well with service workers
      alternatives_considered:
      - Chrome Storage API (size limited)
      - Always online fetching
      - WebSQL (deprecated)
      ai_implementation_note: AI can implement CRUD operations and sync logic patterns
        once data schema is established
    - decision: Separate extension-specific API endpoints on backend
      rationale: Extension has different authentication and data needs than web app,
        allows for extension-specific optimizations and security policies
      alternatives_considered:
      - Reuse existing web API
      - Separate extension backend service
      ai_implementation_note: AI can generate REST endpoints and validation middleware
        following existing backend patterns
    researched_at: '2026-02-08T18:50:46.544061'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:33:39.155301'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: d5d938dc
    planning_hash: 11c5da8e
  technical_notes:
    approach: 'Create a new Turborepo app for the browser extension using React and
      TypeScript. Implement a service worker for background comic syncing and a popup
      interface for comic reading. Use Chrome Extension APIs for storage, authentication,
      and cross-tab communication. Build a lightweight comic viewer with panel navigation
      and reading progress tracking that syncs with the main Morpheus platform.

      '
    external_dependencies:
    - name: '@types/chrome'
      version: ^0.0.246
      reason: TypeScript definitions for Chrome Extension APIs
    - name: webext-polyfill
      version: ^0.10.0
      reason: Cross-browser compatibility for extension APIs
    - name: react-zoom-pan-pinch
      version: ^3.4.0
      reason: Comic panel zoom and navigation functionality
    - name: idb
      version: ^8.0.0
      reason: Promise-based IndexedDB wrapper for comic storage
    - name: '@plasmo/parcel-transformer'
      version: ^0.25.0
      reason: Build tooling optimized for browser extensions
    files_to_modify:
    - path: apps/backend/src/routes/auth.ts
      changes: Add extension-specific authentication endpoints with CORS headers
    - path: apps/backend/src/routes/comics.ts
      changes: Add lightweight comic metadata endpoints for extension consumption
    - path: packages/types/src/comics.ts
      changes: Add extension-specific comic metadata types
    new_files:
    - path: apps/browser-extension/manifest.json
      purpose: Manifest V3 configuration with permissions and content security policy
    - path: apps/browser-extension/src/popup/App.tsx
      purpose: Main popup React application with comic library and reader
    - path: apps/browser-extension/src/popup/components/ComicViewer.tsx
      purpose: Comic reading interface with panel navigation and zoom
    - path: apps/browser-extension/src/popup/components/ComicLibrary.tsx
      purpose: Grid view of user's comics with search and filtering
    - path: apps/browser-extension/src/background/service-worker.ts
      purpose: Background script for comic syncing and offline management
    - path: apps/browser-extension/src/background/sync.ts
      purpose: Reading progress sync logic between extension and backend
    - path: apps/browser-extension/src/storage/comics.ts
      purpose: IndexedDB wrapper for local comic storage and caching
    - path: apps/browser-extension/src/storage/progress.ts
      purpose: Local reading progress management with sync queue
    - path: packages/extension-api/src/client.ts
      purpose: API client optimized for browser extension environment
    - path: packages/extension-api/src/auth.ts
      purpose: Extension authentication utilities with token management
    - path: apps/backend/src/routes/extension/comics.ts
      purpose: Extension-specific comic endpoints with optimized payloads
    - path: apps/backend/src/routes/extension/progress.ts
      purpose: Reading progress sync endpoints for extension
  acceptance_criteria:
  - criterion: Browser extension loads in Chrome/Firefox and displays user's comic
      library
    verification: Load extension in chrome://extensions, verify popup shows authenticated
      user's comics from API
  - criterion: Comic reading experience with panel navigation and zoom controls
    verification: Open any comic, verify left/right navigation, zoom in/out, and reading
      progress saves locally
  - criterion: Offline reading capability with local comic caching
    verification: Download comic while online, disconnect network, verify comic still
      readable with progress sync
  - criterion: Authentication integration with main Morpheus platform
    verification: Login through extension, verify token stored securely and API calls
      authenticated
  - criterion: Reading progress syncs between extension and main platform
    verification: Read comic in extension, check progress reflected in web app and
      vice versa
  testing:
    unit_tests:
    - file: apps/browser-extension/src/__tests__/popup/ComicViewer.test.tsx
      coverage_target: 85%
      scenarios:
      - Comic renders with proper navigation
      - Zoom controls function correctly
      - Loading states handled properly
      - Error states when comic fails to load
    - file: apps/browser-extension/src/__tests__/background/sync.test.ts
      coverage_target: 80%
      scenarios:
      - Background sync updates reading progress
      - Comic download and caching
      - Sync failure handling and retry logic
    - file: packages/extension-api/src/__tests__/client.test.ts
      coverage_target: 90%
      scenarios:
      - API authentication flow
      - Comic fetching with proper error handling
      - Progress update requests
    integration_tests:
    - file: apps/browser-extension/src/__tests__/integration/reader-flow.test.ts
      scenarios:
      - Complete reading flow from library to comic completion
      - Offline-online sync reconciliation
      - Authentication token refresh
    manual_testing:
    - step: Install extension in Chrome and Firefox
      expected: Extension appears in browser toolbar, popup opens without errors
    - step: Login with existing Morpheus account
      expected: Authentication succeeds, user's comic library loads
    - step: Read comic offline after initial download
      expected: Comic accessible without network, progress tracked locally
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Setup browser extension app structure with Turborepo configuration'
      done: false
      ai_friendly: true
    - task: '[AI] Generate manifest.json with proper Manifest V3 permissions and CSP'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design extension architecture and data flow patterns'
      done: false
      ai_friendly: false
    - task: '[AI] Implement React popup components for comic library and viewer'
      done: false
      ai_friendly: true
    - task: '[AI] Create IndexedDB storage utilities for comic caching'
      done: false
      ai_friendly: true
    - task: '[AI] Build service worker for background sync and comic downloads'
      done: false
      ai_friendly: true
    - task: '[AI] Implement extension API client with authentication'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure security model and CORS policies'
      done: false
      ai_friendly: false
    - task: '[AI] Add backend routes for extension-specific API endpoints'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit and integration tests'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Manual testing across Chrome, Firefox, and Safari'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Code review and security audit for extension permissions'
      done: false
      ai_friendly: false
- key: T79
  title: WordPress Plugin
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p2
  effort: 5
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      A WordPress plugin for Morpheus would allow comic creators to sell their AI-generated
      comics directly on their WordPress sites, expanding the distribution reach beyond
      the main Morpheus storefront. This creates a B2B2C model where creators can
      integrate Morpheus comics into their existing WordPress-based websites, blogs,
      or e-commerce stores. Given WordPress powers 43% of websites, this significantly
      expands market reach and provides creators with more control over their sales
      channels.


      **Technical Approach:**

      Build a WordPress plugin that integrates with Morpheus APIs to display and sell
      comics. The plugin should include:

      - Widget/shortcode system for embedding comic previews and purchase flows

      - Integration with existing WordPress e-commerce (WooCommerce) or standalone
      checkout

      - Admin panel for API key configuration and comic selection

      - Webhook handling for order processing and digital delivery

      - Responsive comic reader component that matches WordPress themes


      **AI Suitability Analysis:**

      - High AI effectiveness: PHP boilerplate code, WordPress hooks/filters setup,
      admin form generation, shortcode handlers, CSS styling, unit tests, documentation
      generation

      - Medium AI effectiveness: WooCommerce integration patterns, webhook processing
      logic, API client implementation, settings page layouts

      - Low AI effectiveness: WordPress security best practices decisions, plugin
      architecture design, user experience flow design, marketplace submission strategy


      **Dependencies:**

      - External: WordPress 6.0+, WooCommerce (optional), Guzzle HTTP client, WordPress.org
      plugin guidelines compliance

      - Internal: Morpheus public API endpoints, authentication system, comic metadata
      APIs, purchase/licensing APIs, webhook infrastructure


      **Risks:**

      - WordPress security vulnerabilities: Follow WordPress coding standards, sanitize
      all inputs, use nonces

      - Plugin conflicts with themes/other plugins: Use proper namespacing, minimal
      global scope pollution

      - API rate limiting: Implement caching layer, respect API limits

      - WordPress marketplace approval: Ensure GPL compatibility, follow plugin guidelines
      strictly

      - Version compatibility: Support WordPress 6.0+ and PHP 7.4+


      **Complexity Notes:**

      Medium complexity task. WordPress plugin development has well-established patterns
      that AI can handle effectively. The main complexity lies in integrating with
      Morpheus APIs securely and handling digital product delivery. AI can significantly
      accelerate development of boilerplate WordPress code, but human oversight needed
      for security and user experience decisions.


      **Key Files:**

      - packages/wordpress-plugin/morpheus-comics.php: Main plugin file with headers
      and initialization

      - packages/wordpress-plugin/includes/class-morpheus-api.php: API client class

      - packages/wordpress-plugin/includes/class-morpheus-shortcodes.php: Shortcode
      handlers

      - packages/wordpress-plugin/admin/class-morpheus-admin.php: Admin settings interface

      - packages/wordpress-plugin/public/class-morpheus-public.php: Frontend display
      logic

      '
    design_decisions:
    - decision: Build as standalone WordPress plugin with optional WooCommerce integration
      rationale: Maximizes compatibility across different WordPress setups while providing
        enhanced features for WooCommerce users
      alternatives_considered:
      - WooCommerce extension only
      - Gutenberg block plugin
      - Theme-specific integration
      ai_implementation_note: AI can generate the plugin structure, hooks, and basic
        WooCommerce integration patterns
    - decision: Use WordPress transients API for caching comic metadata
      rationale: Reduces API calls to Morpheus backend while respecting WordPress
        caching patterns
      alternatives_considered:
      - File-based caching
      - Database caching
      - No caching
      ai_implementation_note: AI can implement transient caching patterns and cache
        invalidation logic
    - decision: Implement shortcode-based embedding with Gutenberg block support
      rationale: Supports both classic and block editors, maximizes user adoption
      alternatives_considered:
      - Gutenberg blocks only
      - Widgets only
      - Theme functions
      ai_implementation_note: AI can generate shortcode handlers and block registration
        code following WordPress patterns
    researched_at: '2026-02-08T18:51:11.513321'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:34:07.125564'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 2774f8ea
    planning_hash: 3774b500
  technical_notes:
    approach: 'Create a WordPress plugin package within the Morpheus monorepo that
      provides shortcodes, widgets, and Gutenberg blocks for embedding comics. The
      plugin will authenticate with Morpheus APIs using API keys, cache comic metadata
      using WordPress transients, and handle purchases through either built-in checkout
      or WooCommerce integration. Focus on WordPress coding standards compliance for
      marketplace approval.

      '
    external_dependencies:
    - name: guzzlehttp/guzzle
      version: ^7.0
      reason: HTTP client for Morpheus API communication
    - name: wordpress/coding-standards
      version: ^3.0
      reason: Ensure code quality and marketplace compliance
    files_to_modify:
    - path: packages/backend/src/routes/webhooks.ts
      changes: Add WordPress plugin webhook endpoints for order processing
    - path: packages/backend/src/services/api/public.ts
      changes: Ensure comic metadata APIs support WordPress plugin authentication
    new_files:
    - path: packages/wordpress-plugin/morpheus-comics.php
      purpose: Main plugin file with WordPress headers and initialization
    - path: packages/wordpress-plugin/includes/class-morpheus-api.php
      purpose: API client for Morpheus backend communication
    - path: packages/wordpress-plugin/includes/class-morpheus-shortcodes.php
      purpose: Handle [morpheus-comic] and [morpheus-gallery] shortcodes
    - path: packages/wordpress-plugin/includes/class-morpheus-blocks.php
      purpose: Gutenberg block registration and rendering
    - path: packages/wordpress-plugin/admin/class-morpheus-admin.php
      purpose: Admin settings page and configuration interface
    - path: packages/wordpress-plugin/public/class-morpheus-public.php
      purpose: Frontend display logic and asset enqueuing
    - path: packages/wordpress-plugin/includes/class-morpheus-woocommerce.php
      purpose: WooCommerce integration for e-commerce sites
    - path: packages/wordpress-plugin/includes/class-morpheus-checkout.php
      purpose: Standalone checkout flow for non-WooCommerce sites
    - path: packages/wordpress-plugin/assets/css/morpheus-public.css
      purpose: Frontend styling for comic displays
    - path: packages/wordpress-plugin/assets/js/morpheus-public.js
      purpose: Frontend JavaScript for comic reader and interactions
    - path: packages/wordpress-plugin/assets/js/morpheus-admin.js
      purpose: Admin interface JavaScript
    - path: packages/wordpress-plugin/readme.txt
      purpose: WordPress.org marketplace documentation
    - path: packages/wordpress-plugin/composer.json
      purpose: PHP dependencies (Guzzle HTTP client)
  acceptance_criteria:
  - criterion: Plugin displays comics via shortcodes and Gutenberg blocks with proper
      authentication
    verification: Install plugin, configure API key, use [morpheus-comic id='123']
      shortcode - comic preview displays
  - criterion: Plugin handles purchase flow and delivers digital comics
    verification: Complete purchase through plugin checkout - user receives download
      link/access
  - criterion: Plugin passes WordPress.org marketplace requirements
    verification: Run WordPress Plugin Check tool - no critical issues, GPL compatible
  - criterion: Plugin integrates with WooCommerce for existing e-commerce sites
    verification: Enable WooCommerce integration - comics appear as products with
      proper metadata
  - criterion: Plugin caches API responses and handles rate limiting gracefully
    verification: Monitor API calls with debugging - transients used, graceful degradation
      on API errors
  testing:
    unit_tests:
    - file: packages/wordpress-plugin/tests/test-morpheus-api.php
      coverage_target: 85%
      scenarios:
      - API authentication success/failure
      - Comic data fetching and caching
      - Rate limiting handling
      - Malformed API responses
    - file: packages/wordpress-plugin/tests/test-morpheus-shortcodes.php
      coverage_target: 85%
      scenarios:
      - Valid shortcode rendering
      - Invalid comic ID handling
      - Attribute sanitization
      - Responsive display
    - file: packages/wordpress-plugin/tests/test-morpheus-admin.php
      coverage_target: 80%
      scenarios:
      - Settings save/retrieve
      - API key validation
      - Admin form sanitization
    integration_tests:
    - file: packages/wordpress-plugin/tests/test-integration.php
      scenarios:
      - Full shortcode to API to display flow
      - Purchase flow with webhook processing
      - WooCommerce product creation
    manual_testing:
    - step: Install plugin on WordPress 6.0+ test site
      expected: Plugin activates without errors, admin menu appears
    - step: Test comic display across different WordPress themes
      expected: Comics render responsively in various theme layouts
    - step: Complete purchase flow end-to-end
      expected: User receives comic access after payment
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.55
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create plugin directory structure and main plugin file with WordPress
        headers'
      done: false
      ai_friendly: true
    - task: '[AI] Generate admin settings page class with API key configuration forms'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design plugin architecture and class relationships for security
        and extensibility'
      done: false
      ai_friendly: false
    - task: '[AI] Implement API client class with caching, rate limiting, and error
        handling'
      done: false
      ai_friendly: true
    - task: '[AI] Create shortcode handlers for comic display and gallery views'
      done: false
      ai_friendly: true
    - task: '[AI] Build Gutenberg blocks for modern WordPress editor integration'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Implement secure checkout flow and webhook processing logic'
      done: false
      ai_friendly: false
    - task: '[AI] Generate WooCommerce integration class and product sync functionality'
      done: false
      ai_friendly: true
    - task: '[AI] Create responsive CSS and frontend JavaScript for comic reader'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit tests for all classes and functions'
      done: false
      ai_friendly: true
    - task: '[AI] Generate WordPress.org readme.txt and documentation'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Security review and WordPress coding standards compliance audit'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Manual testing across different WordPress versions and themes'
      done: false
      ai_friendly: false
- key: T80
  title: Plugin Content Display
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p2
  effort: 3
  area: distribution
  dependsOn:
  - T79
  agent_notes:
    research_findings: '**Context:**

      Plugin Content Display addresses the need for third-party developers to showcase
      their content (custom comic styles, templates, effects) within the Morpheus
      marketplace. This creates an ecosystem where users can discover and purchase
      community-created assets, while plugin developers can monetize their work. It''s
      essential for M6''s commerce strategy as it expands revenue streams beyond core
      platform subscriptions.


      **Technical Approach:**

      - React-based plugin showcase components with dynamic content loading

      - Supabase-backed plugin registry with metadata, previews, and permissions

      - CDN integration for plugin assets (images, templates, scripts)

      - Sandboxed preview system for security (iframe or web workers)

      - Plugin manifest system (JSON schema) for metadata and capabilities

      - Integration with existing commerce flow for plugin purchases

      - Server-side plugin validation and approval workflow


      **AI Suitability Analysis:**

      - High AI effectiveness: CRUD operations for plugin registry, database schemas,
      API endpoints, React component boilerplate, TypeScript interfaces, unit tests
      for display logic

      - Medium AI effectiveness: Plugin preview rendering logic, integration with
      existing commerce components, form validation and error handling

      - Low AI effectiveness: Security sandboxing architecture, plugin manifest schema
      design, approval workflow business logic, performance optimization for large
      plugin catalogs


      **Dependencies:**

      - External: react-window (virtualization), react-intersection-observer (lazy
      loading), @supabase/storage-js (asset management), iframe-resizer (sandboxed
      previews)

      - Internal: Commerce service integration, existing storefront components, authentication
      middleware, file upload service


      **Risks:**

      - Security risk: Malicious plugin content execution - mitigation: strict sandboxing
      and CSP headers

      - Performance risk: Large plugin catalogs causing slow load times - mitigation:
      virtualization and pagination

      - UX risk: Inconsistent plugin quality degrading platform experience - mitigation:
      approval workflow and rating system


      **Complexity Notes:**

      More complex than initially estimated due to security considerations around
      third-party content. AI will significantly accelerate CRUD and UI development,
      but security architecture requires careful human design. Expect 60% AI velocity
      boost for implementation phases.


      **Key Files:**

      - apps/storefront/src/pages/plugins/index.tsx: Plugin marketplace page

      - apps/storefront/src/components/PluginCard.tsx: Individual plugin display

      - apps/api/src/routes/plugins/: Plugin CRUD API routes

      - packages/database/supabase/migrations/: Plugin registry schema

      - apps/dashboard/src/pages/plugins/manage.tsx: Developer plugin management

      '
    design_decisions:
    - decision: Use iframe sandboxing for plugin previews
      rationale: Provides strong security isolation while allowing rich preview experiences
      alternatives_considered:
      - Web Workers (limited DOM access)
      - Server-side screenshot generation (static previews only)
      ai_implementation_note: AI can generate iframe communication patterns and resize
        handling logic
    - decision: Implement plugin manifest system with JSON Schema validation
      rationale: Standardizes plugin metadata while enabling flexible content types
      alternatives_considered:
      - Database-only metadata
      - YAML-based manifests
      ai_implementation_note: AI excellent for generating JSON schemas and validation
        logic
    - decision: Use react-window for plugin list virtualization
      rationale: Handles large plugin catalogs efficiently without DOM bloat
      alternatives_considered:
      - Traditional pagination
      - Infinite scroll without virtualization
      ai_implementation_note: AI can implement virtualized list patterns and scrolling
        logic
    researched_at: '2026-02-08T18:51:35.400094'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:34:34.950163'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 0f71a3d5
    planning_hash: ab0e2774
  technical_notes:
    approach: 'Build a secure, performant plugin marketplace within the existing storefront
      using React components backed by Supabase storage and database. Implement sandboxed
      previews via iframes with strict CSP policies. Use virtualization for large
      catalogs and integrate with existing commerce flows for seamless plugin purchases.
      Create developer dashboard for plugin submission and management.

      '
    external_dependencies:
    - name: react-window
      version: ^1.8.8
      reason: Virtualization for large plugin lists performance
    - name: react-intersection-observer
      version: ^9.5.3
      reason: Lazy loading of plugin previews and images
    - name: iframe-resizer
      version: ^4.3.7
      reason: Dynamic iframe sizing for plugin previews
    - name: ajv
      version: ^8.12.0
      reason: JSON schema validation for plugin manifests
    files_to_modify:
    - path: apps/storefront/src/pages/index.tsx
      changes: Add plugin marketplace navigation link to header
    - path: apps/api/src/middleware/auth.ts
      changes: Add plugin developer role validation middleware
    - path: packages/types/src/commerce.ts
      changes: Extend purchase types to include plugin purchases
    new_files:
    - path: apps/storefront/src/pages/plugins/index.tsx
      purpose: Main plugin marketplace page with search, filters, and virtualized
        grid
    - path: apps/storefront/src/components/PluginCard.tsx
      purpose: Individual plugin display card with preview modal
    - path: apps/storefront/src/components/PluginPreview.tsx
      purpose: Sandboxed iframe preview component with security headers
    - path: apps/storefront/src/hooks/usePlugins.ts
      purpose: React hook for plugin data fetching with pagination and caching
    - path: apps/api/src/routes/plugins/index.ts
      purpose: Plugin CRUD API endpoints with validation and approval workflow
    - path: apps/api/src/services/PluginValidationService.ts
      purpose: Plugin manifest validation and security scanning
    - path: packages/database/supabase/migrations/20240101_create_plugins_tables.sql
      purpose: Database schema for plugins, plugin_assets, and plugin_purchases tables
    - path: apps/dashboard/src/pages/plugins/manage.tsx
      purpose: Developer plugin management dashboard with upload and analytics
    - path: apps/dashboard/src/pages/admin/plugins/approve.tsx
      purpose: Admin plugin approval interface with preview and rejection workflow
    - path: packages/types/src/plugins.ts
      purpose: TypeScript interfaces for plugin metadata, manifest, and API responses
  acceptance_criteria:
  - criterion: Plugin marketplace displays paginated list of approved plugins with
      metadata (title, author, price, rating, preview image)
    verification: Navigate to /plugins page, verify grid layout shows plugins with
      all metadata fields populated from database
  - criterion: Plugin previews render securely in sandboxed iframes without executing
      malicious code
    verification: Inspect preview iframe has restrictive sandbox attributes and CSP
      headers prevent script execution
  - criterion: Plugin search and filtering works with virtualized scrolling for catalogs
      >100 items
    verification: Create 150+ test plugins, verify search/filter responsiveness and
      DOM contains <50 rendered items at once
  - criterion: Plugin purchase flow integrates with existing commerce system
    verification: Complete plugin purchase, verify transaction recorded in commerce
      tables and user gains access
  - criterion: Developer dashboard allows plugin upload with validation and approval
      workflow
    verification: Upload plugin via dashboard, verify validation errors shown and
      admin approval required before public listing
  testing:
    unit_tests:
    - file: apps/storefront/src/components/__tests__/PluginCard.test.tsx
      coverage_target: 90%
      scenarios:
      - Plugin card renders with all metadata
      - Preview modal opens/closes correctly
      - Purchase button triggers commerce flow
      - Loading states display properly
    - file: apps/api/src/routes/plugins/__tests__/plugins.test.ts
      coverage_target: 85%
      scenarios:
      - GET /plugins returns paginated results
      - POST /plugins validates manifest schema
      - Plugin approval workflow state changes
      - Asset upload validation and storage
    integration_tests:
    - file: apps/storefront/src/__tests__/integration/plugin-marketplace.test.ts
      scenarios:
      - End-to-end plugin discovery and purchase flow
      - Plugin search and filtering with database queries
      - Sandboxed preview rendering with CSP enforcement
    - file: apps/dashboard/src/__tests__/integration/plugin-management.test.ts
      scenarios:
      - Developer plugin upload and submission flow
      - Admin approval workflow completion
    manual_testing:
    - step: Upload malicious plugin with <script> tags in preview
      expected: Preview renders safely without script execution
    - step: Load plugin marketplace with 200+ plugins and scroll rapidly
      expected: Smooth scrolling with consistent performance, virtualization active
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.6
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database migration for plugins tables with proper indexes
        and relationships'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design plugin manifest JSON schema and security sandboxing architecture'
      done: false
      ai_friendly: false
    - task: '[AI] Implement plugin CRUD API routes with Supabase integration and validation'
      done: false
      ai_friendly: true
    - task: '[AI] Build React components for plugin marketplace with virtualized scrolling'
      done: false
      ai_friendly: true
    - task: '[AI] Create sandboxed preview component with iframe security restrictions'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure CSP headers and security policies for plugin content'
      done: false
      ai_friendly: false
    - task: '[AI] Integrate plugin purchases with existing commerce flow and payment
        processing'
      done: false
      ai_friendly: true
    - task: '[AI] Build developer dashboard for plugin upload and management'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit and integration test suites'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Security review and performance optimization for large plugin
        catalogs'
      done: false
      ai_friendly: false
- key: T81
  title: Social Sharing
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 2
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      Social sharing for Morpheus enables users to share completed comics on social
      platforms (Twitter, Facebook, Reddit, Pinterest), driving organic growth and
      user acquisition. This is crucial for distribution milestone as it creates viral
      loops - shared comics attract new users who may purchase or create their own
      comics. For a novel-to-comic platform, visual content is highly shareable and
      can significantly boost platform visibility.


      **Technical Approach:**

      Implement a comprehensive social sharing system with:

      - Open Graph meta tags for rich previews (comic covers, descriptions)

      - Twitter Cards for enhanced Twitter sharing

      - Dynamic share URLs with tracking parameters

      - Social media APIs for direct posting (Twitter API v2, Facebook Graph API)

      - Share analytics to track virality metrics

      - Pre-generated share images optimized for each platform''s dimensions

      - Deep linking back to comics in the storefront


      **AI Suitability Analysis:**

      - High AI effectiveness: Social media API integrations, Open Graph meta tag
      generation, share button components, analytics tracking code, image optimization
      utilities, unit tests for sharing functionality

      - Medium AI effectiveness: Dynamic meta tag injection in Next.js, URL parameter
      handling, social platform-specific formatting logic

      - Low AI effectiveness: Social media strategy decisions (which platforms to
      prioritize), share image design templates, analytics interpretation and business
      logic


      **Dependencies:**

      - External: next-seo (Open Graph), react-share (share buttons), sharp (image
      processing), twitter-api-v2, facebook-nodejs-business-sdk, analytics libraries

      - Internal: Comic service (for metadata), Image service (for share images),
      Analytics service, User authentication, Storefront routing


      **Risks:**

      - Social API rate limits: Implement proper queuing and retry mechanisms

      - Share image generation performance: Pre-generate and cache share images

      - Privacy concerns with tracking: Ensure GDPR compliance and user consent

      - Platform policy changes: Abstract API calls behind service layer for easier
      updates

      - Share URL accessibility: Ensure shared links work for non-authenticated users


      **Complexity Notes:**

      Medium complexity task - more involved than basic CRUD due to multiple platform
      integrations and image processing requirements. AI will significantly accelerate
      the integration boilerplate and component creation, but human judgment needed
      for UX decisions and platform-specific optimizations.


      **Key Files:**

      - apps/storefront/pages/comic/[id].tsx: Add dynamic meta tags and share buttons

      - apps/storefront/components/social/ShareButtons.tsx: Reusable share component

      - apps/backend/src/services/social-share.service.ts: Social media posting logic

      - apps/backend/src/services/share-image.service.ts: Generate optimized share
      images

      - packages/shared/types/social.ts: Social sharing type definitions

      '
    design_decisions:
    - decision: Use next-seo for Open Graph meta tags with dynamic comic data
      rationale: Industry standard for SEO/social meta tags in Next.js, supports server-side
        rendering for proper social media crawling
      alternatives_considered:
      - Manual meta tag injection
      - react-helmet-async
      - Built-in Next.js Head component
      ai_implementation_note: AI can generate comprehensive meta tag configurations
        and dynamic data binding
    - decision: Pre-generate share images during comic processing pipeline
      rationale: Avoids real-time image generation latency, ensures consistent quality,
        enables CDN caching
      alternatives_considered:
      - On-demand generation
      - Client-side canvas generation
      - Third-party image services
      ai_implementation_note: AI can implement image processing pipeline and Sharp.js
        optimization code
    - decision: Abstract social platform APIs behind unified service interface
      rationale: Handles platform differences, rate limiting, error handling centrally;
        easier to add new platforms
      alternatives_considered:
      - Direct API calls in components
      - Platform-specific services
      - Third-party social management tools
      ai_implementation_note: AI excels at creating API wrappers and service abstractions
        with consistent error handling
    researched_at: '2026-02-08T18:52:03.942911'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:35:02.758646'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: f9ff3bd3
    planning_hash: f87f6471
  technical_notes:
    approach: 'Implement social sharing in three phases: 1) Enhanced meta tags and
      share buttons on comic pages using next-seo and react-share, 2) Backend services
      for direct social posting with proper rate limiting and error handling, 3) Share
      analytics and optimized share image generation pipeline. Focus on Twitter and
      Facebook initially, with extensible architecture for additional platforms.

      '
    external_dependencies:
    - name: next-seo
      version: ^6.4.0
      reason: Open Graph and Twitter Card meta tag management
    - name: react-share
      version: ^4.4.1
      reason: Pre-built social sharing buttons and URL generation
    - name: twitter-api-v2
      version: ^1.15.0
      reason: Direct Twitter posting functionality
    - name: sharp
      version: ^0.33.0
      reason: High-performance image processing for share images
    - name: '@supabase/supabase-js'
      version: ^2.38.0
      reason: Analytics storage and share tracking (already in project)
    files_to_modify:
    - path: apps/storefront/pages/comic/[id].tsx
      changes: Add NextSeo component with dynamic Open Graph tags, integrate ShareButtons
        component
    - path: apps/storefront/pages/_document.tsx
      changes: Add Twitter Card meta tags and basic Open Graph structure
    - path: apps/backend/src/routes/api/index.ts
      changes: Mount social sharing routes
    new_files:
    - path: apps/storefront/components/social/ShareButtons.tsx
      purpose: Reusable share button component with platform-specific styling and
        analytics
    - path: apps/storefront/components/social/ShareModal.tsx
      purpose: Modal for direct social posting with user authentication
    - path: apps/backend/src/services/social-share.service.ts
      purpose: Handle direct posting to social platforms with rate limiting and error
        handling
    - path: apps/backend/src/services/share-image.service.ts
      purpose: Generate and cache optimized share images for different platforms
    - path: apps/backend/src/routes/share.ts
      purpose: API endpoints for social sharing operations
    - path: apps/backend/src/middleware/rate-limit.ts
      purpose: Rate limiting middleware for social API calls
    - path: packages/shared/types/social.ts
      purpose: TypeScript definitions for social sharing interfaces
    - path: apps/backend/src/config/social-platforms.ts
      purpose: Platform-specific configuration (image dimensions, API endpoints, rate
        limits)
  acceptance_criteria:
  - criterion: Comic pages display share buttons for Twitter, Facebook, Reddit, Pinterest
      with correct Open Graph meta tags
    verification: Navigate to /comic/[id], inspect meta tags, verify social platform
      preview tools show comic cover and description
  - criterion: Direct social media posting works with proper rate limiting and error
      handling
    verification: POST /api/share/[platform] with valid auth tokens, verify posts
      appear on platforms and rate limits respected (test with burst requests)
  - criterion: Share images are generated and optimized for each platform's dimensions
    verification: 'Check generated images: Twitter (1200x630), Facebook (1200x630),
      Pinterest (735x1102), verify file sizes <500KB'
  - criterion: Share analytics track clicks and conversions with GDPR compliance
    verification: Click share buttons, verify analytics events in dashboard, check
      cookie consent integration
  - criterion: Shared links work for non-authenticated users and redirect to storefront
    verification: Open shared URLs in incognito mode, verify comic preview loads without
      login requirement
  testing:
    unit_tests:
    - file: apps/backend/src/__tests__/services/social-share.service.test.ts
      coverage_target: 90%
      scenarios:
      - Twitter API posting with valid credentials
      - Facebook Graph API error handling
      - Rate limit detection and queuing
      - Invalid platform rejection
    - file: apps/backend/src/__tests__/services/share-image.service.test.ts
      coverage_target: 85%
      scenarios:
      - Image generation for different platforms
      - Caching mechanisms
      - Error handling for missing comic covers
    - file: apps/storefront/components/social/__tests__/ShareButtons.test.tsx
      coverage_target: 80%
      scenarios:
      - Button rendering for different platforms
      - Analytics event firing
      - Modal interactions
    integration_tests:
    - file: apps/backend/src/__tests__/integration/social-sharing.test.ts
      scenarios:
      - End-to-end sharing flow with mock APIs
      - Share URL generation and resolution
      - Meta tag injection on comic pages
    manual_testing:
    - step: Share comic on Twitter using share button
      expected: Tweet posted with comic cover image, title, and correct link back
        to storefront
    - step: Test social platform preview tools (Twitter Card Validator, Facebook Debugger)
      expected: Rich previews display comic metadata correctly
    - step: Verify rate limiting behavior with multiple rapid share attempts
      expected: Graceful degradation with user-friendly error messages
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.55
  progress:
    status: not-started
    checklist:
    - task: '[AI] Install dependencies (next-seo, react-share, sharp, twitter-api-v2,
        facebook-nodejs-business-sdk)'
      done: false
      ai_friendly: true
    - task: '[AI] Create TypeScript interfaces for social sharing in packages/shared/types/social.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Implement ShareButtons component with react-share integration and
        analytics tracking'
      done: false
      ai_friendly: true
    - task: '[AI] Build social-share.service.ts with Twitter and Facebook API integrations'
      done: false
      ai_friendly: true
    - task: '[AI] Create share-image.service.ts for generating platform-optimized
        images using Sharp'
      done: false
      ai_friendly: true
    - task: '[AI] Implement share API routes with proper validation and rate limiting'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure social media app credentials and review privacy compliance'
      done: false
      ai_friendly: false
    - task: '[AI] Add Open Graph meta tags to comic pages using NextSeo'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit tests for all services and components'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Manual testing of social platform integrations and user experience
        review'
      done: false
      ai_friendly: false
    - task: '[AI] Create integration tests for share URL resolution and meta tag validation'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Final code review focusing on security, rate limiting, and error
        handling'
      done: false
      ai_friendly: false
- key: T82
  title: Analytics Tracking
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 2
  area: distribution
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      Analytics tracking is essential for a commerce platform like Morpheus to understand
      user behavior, conversion funnels, and business metrics. This includes tracking
      comic creation flows, purchase analytics, user engagement, and distribution
      performance. Given we''re in M6 (Commerce & Distribution), this supports revenue
      optimization, A/B testing, and data-driven product decisions.


      **Technical Approach:**

      Implement a multi-layered analytics architecture:

      1. Client-side tracking with privacy-compliant tools (PostHog/Mixpanel)

      2. Server-side event streaming for reliable data collection

      3. Custom analytics service in backend for internal metrics

      4. Dashboard integration for real-time monitoring

      5. GDPR/CCPA compliance with consent management


      Recommended stack:

      - PostHog (self-hosted option available) for product analytics

      - Segment for data pipeline management

      - Custom Fastify service for internal event processing

      - React hooks for consistent client-side tracking

      - Supabase functions for server-side event enrichment


      **AI Suitability Analysis:**

      - High AI effectiveness: Event tracking utilities, React hooks, TypeScript interfaces,
      test scenarios, CRUD for analytics data, dashboard components

      - Medium AI effectiveness: Integration adapters, data transformation pipelines,
      consent management flows

      - Low AI effectiveness: Privacy policy compliance, analytics strategy, KPI definitions,
      data retention policies


      **Dependencies:**

      - External: @posthog/posthog-js, @segment/analytics-node, @hookform/resolvers
      (for consent forms)

      - Internal: Authentication service, user management, commerce APIs, dashboard
      routing


      **Risks:**

      - Privacy compliance risk: Implement consent management early and audit data
      collection

      - Performance impact: Use async tracking and avoid blocking main thread

      - Data accuracy: Server-side validation prevents client manipulation

      - Vendor lock-in: Abstract tracking behind interfaces for easy migration

      - GDPR violations: Legal review of data collection and retention policies required


      **Complexity Notes:**

      Medium complexity - more involved than basic CRUD due to privacy compliance
      and multi-platform tracking. AI can significantly accelerate the implementation
      of tracking utilities and dashboard components, but human oversight needed for
      privacy strategy and compliance requirements.


      **Key Files:**

      - packages/analytics/: New package for tracking utilities

      - apps/api/src/services/analytics.ts: Server-side event processing

      - apps/dashboard/src/hooks/useAnalytics.ts: React tracking hooks

      - apps/storefront/src/components/ConsentBanner.tsx: GDPR compliance

      - apps/dashboard/src/pages/analytics/: Analytics dashboard pages

      '
    design_decisions:
    - decision: Use PostHog as primary analytics platform with Segment as data pipeline
      rationale: PostHog offers self-hosting option for data sovereignty, comprehensive
        feature set including A/B testing, and good React integration. Segment provides
        vendor-agnostic data pipeline.
      alternatives_considered:
      - Google Analytics 4 + Custom backend
      - Mixpanel + Custom pipeline
      - Full custom solution
      ai_implementation_note: AI can generate PostHog integration boilerplate, React
        tracking hooks, and dashboard components following PostHog's documented patterns
    - decision: Implement server-side event validation and enrichment
      rationale: Prevents data manipulation, adds server context (IP geolocation,
        user segments), and ensures data quality for business decisions
      alternatives_considered:
      - Client-side only tracking
      - Hybrid with minimal server involvement
      ai_implementation_note: AI excellent for generating Fastify route handlers,
        validation schemas with Zod, and event transformation logic
    - decision: Create analytics package in monorepo for shared tracking utilities
      rationale: Ensures consistent tracking across dashboard and storefront, reduces
        code duplication, enables type-safe event definitions
      alternatives_considered:
      - Inline tracking in each app
      - External shared library
      ai_implementation_note: AI can scaffold package structure, generate TypeScript
        interfaces for events, and create utility functions
    researched_at: '2026-02-08T18:52:31.486956'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:35:30.422265'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 8a9309a4
    planning_hash: fce8b66b
  technical_notes:
    approach: 'Create a shared analytics package with TypeScript event definitions
      and tracking utilities. Implement PostHog integration with custom React hooks
      for consistent client-side tracking across dashboard and storefront. Add Fastify
      analytics service for server-side event processing and validation. Build consent
      management system for GDPR compliance. Create analytics dashboard pages using
      existing UI components for visualizing key metrics.

      '
    external_dependencies:
    - name: posthog-js
      version: ^1.96.0
      reason: Client-side analytics tracking with React integration
    - name: posthog-node
      version: ^3.6.0
      reason: Server-side event tracking and user identification
    - name: '@segment/analytics-node'
      version: ^1.1.0
      reason: Optional data pipeline for multi-destination event streaming
    - name: js-cookie
      version: ^3.0.5
      reason: GDPR-compliant cookie management for consent tracking
    files_to_modify:
    - path: package.json
      changes: Add analytics package to workspace dependencies
    - path: apps/api/src/server.ts
      changes: Register analytics routes and middleware
    - path: apps/dashboard/src/app.tsx
      changes: Initialize analytics provider and consent management
    - path: apps/storefront/src/app.tsx
      changes: Initialize analytics provider and consent banner
    new_files:
    - path: packages/analytics/package.json
      purpose: Analytics package configuration and dependencies
    - path: packages/analytics/src/types/events.ts
      purpose: TypeScript definitions for all analytics events
    - path: packages/analytics/src/tracking/posthog.ts
      purpose: PostHog integration and configuration
    - path: packages/analytics/src/hooks/useAnalytics.ts
      purpose: React hooks for consistent client-side tracking
    - path: packages/analytics/src/consent/manager.ts
      purpose: GDPR consent management utilities
    - path: packages/analytics/src/validation/events.ts
      purpose: Event validation schemas using Zod
    - path: apps/api/src/routes/analytics.ts
      purpose: Analytics API endpoints for event collection
    - path: apps/api/src/services/analytics.ts
      purpose: Server-side analytics processing and enrichment
    - path: apps/api/src/middleware/analytics.ts
      purpose: Analytics middleware for automatic server-side tracking
    - path: apps/dashboard/src/pages/analytics/index.tsx
      purpose: Main analytics dashboard page
    - path: apps/dashboard/src/pages/analytics/metrics.tsx
      purpose: Key metrics and KPI displays
    - path: apps/dashboard/src/components/analytics/Chart.tsx
      purpose: Reusable chart components for analytics data
    - path: apps/storefront/src/components/ConsentBanner.tsx
      purpose: GDPR consent banner component
    - path: apps/storefront/src/hooks/useEcommerceTracking.ts
      purpose: E-commerce specific tracking hooks
  acceptance_criteria:
  - criterion: Analytics events are tracked consistently across dashboard and storefront
      applications
    verification: Run `npm test` and verify tracking events fire correctly in browser
      dev tools Network tab for create comic, purchase, and navigation flows
  - criterion: GDPR consent banner appears on first visit and persists user preference
    verification: Clear localStorage, visit storefront/dashboard, verify banner shows,
      accept/decline, refresh page and verify preference persisted
  - criterion: Analytics dashboard displays key metrics with real-time updates
    verification: Navigate to /analytics in dashboard, perform tracked actions in
      another tab, verify metrics update within 30 seconds
  - criterion: Server-side analytics service validates and enriches client events
    verification: POST to /api/analytics/events endpoint, verify server logs show
      validation and enrichment, check database for stored events
  - criterion: Analytics package provides type-safe event definitions and utilities
    verification: Import analytics package in TypeScript, verify autocomplete works
      for event types, run `npm run type-check` successfully
  testing:
    unit_tests:
    - file: packages/analytics/src/__tests__/events.test.ts
      coverage_target: 90%
      scenarios:
      - Event validation with valid payloads
      - Event validation with invalid payloads
      - Event serialization and deserialization
    - file: packages/analytics/src/__tests__/tracking.test.ts
      coverage_target: 85%
      scenarios:
      - Track function with PostHog integration
      - Track function with network failures
      - Consent state management
    - file: apps/api/src/__tests__/analytics.test.ts
      coverage_target: 85%
      scenarios:
      - Event processing and validation
      - Event enrichment with user context
      - Rate limiting and spam protection
    integration_tests:
    - file: apps/dashboard/src/__tests__/integration/analytics.test.ts
      scenarios:
      - Full analytics flow from component to server
      - Consent management integration
    - file: apps/storefront/src/__tests__/integration/tracking.test.ts
      scenarios:
      - E-commerce tracking through purchase flow
    manual_testing:
    - step: Create comic and verify tracking events
      expected: Comic creation events appear in PostHog and analytics dashboard
    - step: Test consent banner on incognito browser
      expected: Banner appears, preferences persist, tracking respects consent
    - step: Load analytics dashboard with sample data
      expected: Charts render correctly, filters work, real-time updates function
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create analytics package structure with TypeScript event definitions'
      done: false
      ai_friendly: true
    - task: '[AI] Implement PostHog integration utilities and React hooks'
      done: false
      ai_friendly: true
    - task: '[AI] Build consent management system with localStorage persistence'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Define analytics strategy, KPIs, and data retention policies'
      done: false
      ai_friendly: false
    - task: '[AI] Create server-side analytics service with event validation'
      done: false
      ai_friendly: true
    - task: '[AI] Implement analytics API routes and middleware'
      done: false
      ai_friendly: true
    - task: '[AI] Build analytics dashboard components and pages'
      done: false
      ai_friendly: true
    - task: '[AI] Create GDPR consent banner component'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit and integration tests'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Review privacy compliance and conduct legal audit'
      done: false
      ai_friendly: false
    - task: '[AI] Generate documentation and setup guides'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Final code review and security audit'
      done: false
      ai_friendly: false
- key: T83
  title: Stripe Integration
  type: Feature
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 5
  area: ecommerce
  dependsOn:
  - T25
  agent_notes:
    research_findings: '**Context:**

      Stripe Integration is essential for monetizing the Morpheus platform by enabling
      users to purchase novel-to-comic transformations, subscription plans, and potentially
      physical comic prints. This task provides the payment infrastructure for both
      one-time purchases and recurring subscriptions, supporting the business model
      transition from MVP to revenue-generating platform. Given the M6 milestone focus
      on commerce & distribution, this is foundational for all downstream monetization
      features.


      **Technical Approach:**

      Implement Stripe using their official Node.js SDK with webhook-based event handling
      for security. Use Stripe Checkout for hosted payment flows (AI-friendly) and
      Stripe Elements for custom payment forms where needed. Follow the backend-centric
      approach with Fastify handling webhook verification and payment processing,
      while Next.js frontend creates Checkout Sessions via API calls. Store payment
      metadata in Supabase for order tracking and user purchase history. Implement
      idempotent payment processing using Stripe''s idempotency keys.


      **AI Suitability Analysis:**

      - High AI effectiveness: Stripe SDK integration boilerplate, webhook endpoint
      handlers, payment status CRUD operations, TypeScript types for Stripe objects,
      basic payment form components, unit tests for payment flows

      - Medium AI effectiveness: Webhook event processing logic, payment retry mechanisms,
      Supabase schema updates for payment tracking, integration with existing user
      authentication

      - Low AI effectiveness: Payment flow UX design decisions, subscription tier
      pricing strategy, PCI compliance architecture, error handling UX for failed
      payments


      **Dependencies:**

      - External: stripe (^14.0.0), @stripe/stripe-js (^2.0.0), @stripe/react-stripe-js
      (^2.0.0)

      - Internal: Supabase auth service, user management system, order/product catalog
      (may need creation), email notification system, existing API authentication
      middleware


      **Risks:**

      - Webhook security: Implement proper signature verification and HTTPS-only endpoints
      in production

      - Payment state synchronization: Use Stripe webhooks as source of truth, not
      client-side payment confirmations

      - PCI compliance: Avoid storing sensitive payment data, use Stripe''s hosted
      solutions where possible

      - Currency/tax handling: Start with USD-only, plan for international expansion
      complexity

      - Subscription management complexity: Stripe billing can become complex with
      upgrades/downgrades


      **Complexity Notes:**

      Initial estimate likely underestimated webhook complexity and payment state
      management. However, AI can significantly accelerate implementation of standard
      Stripe patterns. The integration itself is well-documented, but designing payment
      flows that integrate smoothly with existing Morpheus UX requires human judgment.
      AI will be highly effective for the 70% boilerplate code, making this faster
      than traditional estimates.


      **Key Files:**

      - packages/api/src/routes/payments/: New payment route handlers

      - packages/api/src/services/stripe.ts: Stripe service wrapper

      - packages/api/src/webhooks/stripe.ts: Webhook processing logic

      - packages/web/src/components/payment/: Payment form components

      - packages/database/migrations/: Payment tables schema

      - packages/web/src/pages/api/create-checkout-session.ts: Next.js API route

      '
    design_decisions:
    - decision: Use Stripe Checkout for initial implementation over custom Elements
      rationale: Faster implementation, built-in PCI compliance, mobile-optimized,
        and AI can easily generate checkout session creation code
      alternatives_considered:
      - Custom Stripe Elements forms
      - Alternative payment processors like PayPal
      ai_implementation_note: AI excels at Checkout Session API integration - can
        generate complete webhook handlers and session creation endpoints
    - decision: Webhook-first payment processing with optimistic UI updates
      rationale: Webhooks are the reliable source of truth for payment status, prevents
        race conditions and ensures payment integrity
      alternatives_considered:
      - Client-side payment confirmation only
      - Polling-based status checking
      ai_implementation_note: AI can generate comprehensive webhook handlers for all
        Stripe event types with proper error handling
    - decision: Separate payments microservice pattern within Fastify monolith
      rationale: Isolates payment logic for security auditing while maintaining monolith
        simplicity
      alternatives_considered:
      - Embedded payment logic in existing routes
      - Separate payment service deployment
      ai_implementation_note: AI can scaffold the entire service structure including
        dependency injection and testing setup
    researched_at: '2026-02-08T18:53:01.390554'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:35:57.029060'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 9ea2a44e
    planning_hash: bb842583
  technical_notes:
    approach: 'Create a dedicated payments service in the Fastify backend that handles
      Stripe integration through official SDKs. Implement secure webhook endpoints
      for payment event processing, storing payment metadata in Supabase for order
      tracking. Build React components using Stripe''s hosted Checkout for MVP, with
      webhook-driven payment status updates. Use TypeScript throughout for type safety
      with Stripe''s comprehensive type definitions.

      '
    external_dependencies:
    - name: stripe
      version: ^14.0.0
      reason: Official Stripe Node.js SDK for backend payment processing and webhook
        handling
    - name: '@stripe/stripe-js'
      version: ^2.0.0
      reason: Official Stripe JavaScript library for frontend Checkout Session redirects
    - name: '@stripe/react-stripe-js'
      version: ^2.0.0
      reason: React components for Stripe Elements if custom payment forms needed
        later
    files_to_modify:
    - path: packages/api/src/app.ts
      changes: Register payment routes and webhook middleware
    - path: packages/database/supabase/migrations/001_initial.sql
      changes: Add payment_transactions and payment_methods tables
    - path: packages/web/src/components/layout/Header.tsx
      changes: Add navigation link to payment history
    new_files:
    - path: packages/api/src/services/stripe.ts
      purpose: Stripe SDK wrapper with error handling and type safety
    - path: packages/api/src/routes/payments/index.ts
      purpose: Payment route handlers for checkout, history, and status
    - path: packages/api/src/routes/payments/webhooks.ts
      purpose: Stripe webhook event processing
    - path: packages/api/src/schemas/payment.ts
      purpose: Zod schemas for payment request/response validation
    - path: packages/web/src/components/payment/CheckoutButton.tsx
      purpose: React component for initiating Stripe Checkout
    - path: packages/web/src/components/payment/PaymentHistory.tsx
      purpose: Display user's payment transaction history
    - path: packages/web/src/pages/payment/success.tsx
      purpose: Payment confirmation page after successful checkout
    - path: packages/web/src/pages/payment/cancel.tsx
      purpose: Payment cancellation page
    - path: packages/web/src/hooks/usePayments.ts
      purpose: React hook for payment-related API calls
    - path: packages/api/src/types/stripe.ts
      purpose: Extended TypeScript types for Stripe integration
  acceptance_criteria:
  - criterion: Users can complete one-time payments for novel transformations via
      Stripe Checkout
    verification: Navigate to payment flow, complete test transaction, verify payment
      success page and Stripe dashboard shows successful payment
  - criterion: Webhook events properly update payment status in Supabase database
    verification: Use Stripe CLI to trigger webhook events, verify database payment_transactions
      table updates correctly with status changes
  - criterion: Failed payments display appropriate error messages and allow retry
    verification: Use test card 4000000000000002 (declined), verify error message
      shown and retry flow works
  - criterion: Payment history is accessible to authenticated users
    verification: Complete payment, check /account/payments page shows transaction
      history with correct amounts and dates
  - criterion: All payment endpoints require authentication and validate user permissions
    verification: Test payment endpoints without auth token return 401, test accessing
      other users' payment data returns 403
  testing:
    unit_tests:
    - file: packages/api/src/services/__tests__/stripe.test.ts
      coverage_target: 90%
      scenarios:
      - Create checkout session with valid product data
      - Webhook signature verification success/failure
      - Payment intent creation and retrieval
      - Error handling for invalid Stripe API responses
      - Idempotency key generation and usage
    - file: packages/api/src/routes/payments/__tests__/payments.test.ts
      coverage_target: 85%
      scenarios:
      - POST /payments/create-checkout-session with valid auth
      - GET /payments/history returns user's transactions
      - Webhook endpoint processes payment.succeeded event
      - Unauthorized access returns proper error codes
    integration_tests:
    - file: packages/api/src/__tests__/integration/stripe-flow.test.ts
      scenarios:
      - Complete payment flow from checkout session creation to webhook processing
      - Database state consistency after payment events
      - Multiple concurrent webhook events handling
    manual_testing:
    - step: Complete payment flow with test card 4242424242424242
      expected: Successful payment confirmation and database record creation
    - step: Test webhook delivery using Stripe CLI local forwarding
      expected: Events processed and logged correctly in application
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Install and configure Stripe dependencies (stripe, @stripe/stripe-js,
        @stripe/react-stripe-js)'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design database schema for payment_transactions and payment_methods
        tables'
      done: false
      ai_friendly: false
    - task: '[AI] Create Stripe service wrapper with SDK initialization and basic
        methods'
      done: false
      ai_friendly: true
    - task: '[AI] Implement payment route handlers for checkout session creation and
        payment history'
      done: false
      ai_friendly: true
    - task: '[AI] Build webhook endpoint with signature verification and event processing'
      done: false
      ai_friendly: true
    - task: '[AI] Create React components for payment UI (CheckoutButton, PaymentHistory)'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design payment flow UX and error handling strategies'
      done: false
      ai_friendly: false
    - task: '[AI] Implement database operations for payment tracking and user history'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit tests for all payment services and routes'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Security review of webhook handling and payment data storage'
      done: false
      ai_friendly: false
    - task: '[AI] Generate API documentation for payment endpoints'
      done: false
      ai_friendly: true
- key: T84
  title: Stripe Webhook Handler
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 3
  area: ecommerce
  dependsOn:
  - T83
  agent_notes:
    research_findings: '**Context:**

      Stripe webhook handlers are critical for maintaining data consistency between
      Stripe''s payment system and Morpheus''s internal state. When users purchase
      comics, subscriptions, or credits, Stripe processes the payment and sends webhooks
      to notify our system of status changes (payment succeeded, failed, refunded,
      subscription cancelled, etc.). Without proper webhook handling, the platform
      could show incorrect purchase status, fail to deliver digital products, or have
      billing inconsistencies.


      **Technical Approach:**

      - Use Stripe''s official Node.js SDK (@stripe/stripe-node) for webhook signature
      verification

      - Implement webhook endpoint in Fastify with raw body parsing (required for
      signature verification)

      - Use idempotency keys and database transactions to handle duplicate/retry webhooks

      - Implement event-driven architecture with internal event bus for decoupling

      - Store webhook events in database for audit trail and retry mechanisms

      - Use Zod schemas for webhook payload validation

      - Implement circuit breaker pattern for downstream service calls


      **AI Suitability Analysis:**

      - High AI effectiveness: Webhook event handlers (CRUD operations), Zod validation
      schemas, unit tests for individual event types, database transaction boilerplate,
      error handling patterns

      - Medium AI effectiveness: Fastify route setup, Stripe SDK integration, event
      dispatching logic, integration tests

      - Low AI effectiveness: Business logic decisions (what happens when payment
      fails), retry/idempotency strategies, security considerations, webhook event
      priority/ordering


      **Dependencies:**

      - External: @stripe/stripe-node, micro (for raw body parsing), zod (validation)

      - Internal: Database service, user management service, order/purchase service,
      email notification service, audit logging service


      **Risks:**

      - Webhook replay attacks: Use Stripe signature verification and timestamp validation

      - Duplicate processing: Implement idempotency using Stripe event IDs

      - Race conditions: Use database transactions and proper locking

      - Webhook delivery failures: Implement retry mechanism with exponential backoff

      - Schema changes: Version webhook handlers and maintain backward compatibility

      - Performance bottlenecks: Process webhooks asynchronously, avoid blocking operations


      **Complexity Notes:**

      This task is more complex than typical CRUD operations due to security, idempotency,
      and error handling requirements. However, Stripe provides excellent documentation
      and the patterns are well-established. AI can handle 60-70% of the implementation
      (boilerplate, basic handlers, tests), but human oversight is crucial for business
      logic and security considerations.


      **Key Files:**

      - apps/api/src/routes/webhooks/stripe.ts: Main webhook endpoint

      - apps/api/src/services/stripe-webhook-handler.ts: Business logic service

      - apps/api/src/types/stripe-webhooks.ts: Zod schemas and TypeScript types

      - apps/api/src/lib/stripe.ts: Stripe client configuration

      - packages/database/src/schema/webhook-events.sql: Webhook audit table

      '
    design_decisions:
    - decision: Use separate handler functions for each Stripe event type
      rationale: Improves maintainability, testability, and allows different error
        handling strategies per event type
      alternatives_considered:
      - Single monolithic handler
      - Event-driven microservices
      ai_implementation_note: AI can generate individual handler functions following
        established patterns
    - decision: Store all webhook events in audit table before processing
      rationale: Enables replay, debugging, and compliance requirements. Provides
        idempotency check.
      alternatives_considered:
      - Process immediately without storage
      - Store only failed events
      ai_implementation_note: AI excellent for generating database schema and CRUD
        operations
    - decision: Use Fastify's async/await with database transactions
      rationale: Ensures atomicity and integrates well with existing Fastify architecture
      alternatives_considered:
      - Event sourcing pattern
      - Message queue processing
      ai_implementation_note: AI can generate transaction boilerplate and error handling
    researched_at: '2026-02-08T18:53:26.891510'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:36:21.590436'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 5fc8ec0c
    planning_hash: 1f1ed6ab
  technical_notes:
    approach: 'Implement a Fastify POST route at /webhooks/stripe that verifies Stripe
      signatures, stores events for idempotency, and dispatches to specific handlers
      based on event type. Each handler (payment_intent.succeeded, customer.subscription.deleted,
      etc.) will perform the necessary business logic using database transactions.
      Include comprehensive error handling, logging, and monitoring.

      '
    external_dependencies:
    - name: '@stripe/stripe-node'
      version: ^14.0.0
      reason: Official Stripe SDK for webhook signature verification and API interactions
    - name: micro
      version: ^10.0.1
      reason: Raw body parsing required for Stripe webhook signature verification
    - name: zod
      version: ^3.22.0
      reason: Runtime validation of webhook payloads and type safety
    files_to_modify:
    - path: apps/api/src/lib/stripe.ts
      changes: Add webhook signature verification utilities and Stripe client config
    - path: packages/database/src/schema/index.ts
      changes: Add webhook_events table schema and related types
    - path: apps/api/src/routes/index.ts
      changes: Register stripe webhook route with raw body parsing middleware
    new_files:
    - path: apps/api/src/routes/webhooks/stripe.ts
      purpose: Main webhook endpoint with signature validation and event routing
    - path: apps/api/src/services/stripe-webhook-handler.ts
      purpose: Business logic service with event-specific handlers and database operations
    - path: apps/api/src/types/stripe-webhooks.ts
      purpose: Zod schemas and TypeScript types for webhook payload validation
    - path: apps/api/src/services/webhook-processors/payment-intent.ts
      purpose: Payment intent event handlers (succeeded, failed, cancelled)
    - path: apps/api/src/services/webhook-processors/subscription.ts
      purpose: Subscription event handlers (created, updated, deleted, trial_will_end)
    - path: apps/api/src/services/webhook-processors/invoice.ts
      purpose: Invoice event handlers (payment_succeeded, payment_failed)
    - path: packages/database/src/schema/webhook-events.sql
      purpose: Database table for webhook audit trail and idempotency
    - path: apps/api/src/lib/webhook-idempotency.ts
      purpose: Idempotency checking and duplicate detection utilities
  acceptance_criteria:
  - criterion: Webhook endpoint validates Stripe signatures and rejects invalid requests
    verification: Send test webhook with invalid signature, expect 400 response with
      signature validation error
  - criterion: Payment success events create/update orders and deliver digital products
    verification: Send payment_intent.succeeded webhook, verify order status updated
      and user granted access
  - criterion: Subscription events properly update user subscription status
    verification: Send customer.subscription.deleted webhook, verify user subscription
      cancelled in database
  - criterion: Duplicate webhooks are handled idempotently without side effects
    verification: Send identical webhook twice, verify only one database update occurs
  - criterion: All webhook events are logged for audit trail with proper error handling
    verification: Check webhook_events table contains all processed events with timestamps
      and status
  testing:
    unit_tests:
    - file: apps/api/src/__tests__/services/stripe-webhook-handler.test.ts
      coverage_target: 90%
      scenarios:
      - Payment intent succeeded handler
      - Payment intent failed handler
      - Subscription created/updated/deleted handlers
      - Invoice payment succeeded/failed handlers
      - Idempotency key duplicate detection
      - Invalid event type handling
      - Database transaction rollback on errors
    - file: apps/api/src/__tests__/routes/webhooks/stripe.test.ts
      coverage_target: 85%
      scenarios:
      - Valid Stripe signature verification
      - Invalid signature rejection
      - Malformed JSON handling
      - Unknown event type processing
      - Raw body parsing
    integration_tests:
    - file: apps/api/src/__tests__/integration/stripe-webhooks.test.ts
      scenarios:
      - End-to-end webhook processing with database updates
      - Order fulfillment after successful payment
      - Subscription status synchronization
      - Error recovery and retry mechanisms
    manual_testing:
    - step: Use Stripe CLI to forward test webhooks to local endpoint
      expected: Webhook processed successfully, events logged in database
    - step: Simulate webhook retry by sending same event multiple times
      expected: Only first webhook processed, subsequent ones marked as duplicate
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database schema for webhook_events table with proper indexes'
      done: false
      ai_friendly: true
    - task: '[AI] Implement Zod validation schemas for Stripe webhook event types'
      done: false
      ai_friendly: true
    - task: '[AI] Create Fastify route with raw body parsing and signature verification'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design business logic for payment success/failure handling'
      done: false
      ai_friendly: false
    - task: '[AI] Implement individual webhook event processors with database transactions'
      done: false
      ai_friendly: true
    - task: '[AI] Create idempotency service using Stripe event IDs'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit tests for all event handlers'
      done: false
      ai_friendly: true
    - task: '[AI] Implement error handling and logging throughout webhook flow'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Review security implementation and business logic correctness'
      done: false
      ai_friendly: false
    - task: '[AI] Create integration tests with mock Stripe webhooks'
      done: false
      ai_friendly: true
- key: T85
  title: Storefront UI
  type: Feature
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 5
  area: ecommerce
  dependsOn: []
  agent_notes:
    research_findings: '**Context:**

      The Storefront UI is the customer-facing interface where users browse and purchase
      AI-generated comics created through the Morpheus platform. This is distinct
      from the admin dashboard and serves as the primary revenue-generating touchpoint.
      It needs to showcase comics with rich previews, handle secure payments, manage
      digital deliveries, and provide an excellent discovery experience. This is critical
      for M6 as it directly enables monetization of the platform.


      **Technical Approach:**

      Build as a separate Next.js 16 app within the monorepo using App Router for
      optimal SEO and performance. Implement server-side rendering for comic listings
      and product pages to improve discoverability. Use React Server Components for
      data fetching, with client components only for interactive elements (cart, favorites,
      search filters). Integrate Stripe for payments with webhook handling for order
      fulfillment. Implement a cart system with local storage persistence and server
      sync. Use Supabase RLS policies for secure comic access and purchase verification.


      **AI Suitability Analysis:**

      - High AI effectiveness: Component scaffolding, form handling, responsive layouts,
      basic e-commerce CRUD operations, Stripe integration boilerplate, search/filter
      components, cart state management, product listing components

      - Medium AI effectiveness: SEO optimization, performance optimizations, complex
      state synchronization, payment flow integration, image optimization pipelines

      - Low AI effectiveness: UX/UI design decisions, payment security architecture,
      business logic for pricing/licensing models, accessibility considerations, conversion
      optimization strategies


      **Dependencies:**

      - External: @stripe/stripe-js, @stripe/react-stripe-js, next-themes, framer-motion,
      @tanstack/react-query, zustand, react-hook-form, zod

      - Internal: Shared design system components, authentication service, comic metadata
      APIs, user management service, file storage service for comic assets


      **Risks:**

      - Payment security vulnerabilities: Implement PCI compliance best practices,
      use Stripe''s secure elements, never store card data

      - Performance issues with high-resolution comic images: Implement Next.js Image
      optimization, lazy loading, and CDN integration

      - SEO challenges for dynamic content: Use proper meta tags, structured data,
      and ensure server-side rendering works correctly

      - Cart abandonment due to complex checkout: Implement guest checkout, save cart
      state, and streamlined flow

      - Digital piracy concerns: Implement DRM-like features, watermarking, or limited
      preview access


      **Complexity Notes:**

      This is more complex than a typical e-commerce storefront due to digital content
      delivery, preview generation, and integration with the comic generation pipeline.
      AI can significantly accelerate the standard e-commerce patterns, but the custom
      digital delivery and preview systems will require careful human architecture.
      The integration with existing Morpheus services adds complexity but AI can help
      with the integration boilerplate.


      **Key Files:**

      - apps/storefront/: New Next.js app directory

      - packages/ui/: Extend with storefront-specific components

      - packages/database/: Add commerce-related schemas and queries

      - apps/api/: Add storefront-specific endpoints for cart, checkout, digital delivery

      - packages/auth/: Extend for storefront user management

      '
    design_decisions:
    - decision: Separate Next.js app for storefront vs integrated dashboard pages
      rationale: Different performance requirements, SEO needs, and user experiences.
        Storefront needs public accessibility and search engine optimization while
        dashboard is private admin tool
      alternatives_considered:
      - Shared Next.js app with different layouts
      - Separate domain/subdomain deployment
      ai_implementation_note: AI can scaffold the entire app structure and routing
        once architecture is decided
    - decision: Server-side rendering with App Router for product discovery
      rationale: Critical for SEO, social media previews, and initial page load performance.
        Comic previews need to be discoverable by search engines
      alternatives_considered:
      - Client-side rendering with SPA
      - Static generation with ISR
      ai_implementation_note: AI excels at implementing SSR patterns and can generate
        proper metadata handling
    - decision: Zustand for client-side cart state management
      rationale: Lightweight, TypeScript-friendly, and good for cart persistence across
        sessions. Less boilerplate than Redux
      alternatives_considered:
      - Redux Toolkit
      - React Context
      - SWR/React Query only
      ai_implementation_note: AI can implement entire cart state management including
        persistence and sync logic
    - decision: Stripe Elements for payment processing
      rationale: Industry standard, PCI compliant, handles international payments
        and currencies, strong webhook system for order fulfillment
      alternatives_considered:
      - PayPal
      - Square
      - Custom payment processor
      ai_implementation_note: AI can implement standard Stripe integration patterns
        but human review needed for security architecture
    researched_at: '2026-02-08T18:54:00.309068'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:36:52.274448'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: dc4cd666
    planning_hash: c76104e7
  technical_notes:
    approach: 'Create a new Next.js 16 storefront app using App Router with server-side
      rendered product pages for SEO. Implement a modern e-commerce experience with
      cart management, user authentication integration, and Stripe payments. Build
      comic preview components with optimized image delivery and lazy loading. Use
      React Server Components for data fetching and client components for interactive
      cart/search features. Integrate with existing Morpheus APIs for comic metadata
      and user management while adding new commerce-specific endpoints.

      '
    external_dependencies:
    - name: '@stripe/stripe-js'
      version: ^4.0.0
      reason: Client-side Stripe integration for secure payment processing
    - name: '@stripe/react-stripe-js'
      version: ^2.0.0
      reason: React components for Stripe Elements integration
    - name: zustand
      version: ^4.5.0
      reason: Lightweight state management for cart and user preferences
    - name: '@tanstack/react-query'
      version: ^5.0.0
      reason: Server state management and caching for product data
    - name: framer-motion
      version: ^11.0.0
      reason: Smooth animations for cart interactions and page transitions
    - name: react-hook-form
      version: ^7.48.0
      reason: Form handling for checkout and user preferences
    - name: next-themes
      version: ^0.2.1
      reason: Theme switching capability for storefront branding
    new_files:
    - path: apps/storefront/package.json
      purpose: Next.js 16 app configuration with storefront dependencies
    - path: apps/storefront/src/app/layout.tsx
      purpose: Root layout with theme provider and global navigation
    - path: apps/storefront/src/app/page.tsx
      purpose: Homepage with featured comics and hero section
    - path: apps/storefront/src/app/comics/page.tsx
      purpose: Server-rendered comic listing with pagination
    - path: apps/storefront/src/app/comics/[id]/page.tsx
      purpose: Server-rendered comic detail page with metadata
    - path: apps/storefront/src/components/ComicCard.tsx
      purpose: Reusable comic preview component with purchase button
    - path: apps/storefront/src/components/CartDrawer.tsx
      purpose: Sliding cart panel with item management
    - path: apps/storefront/src/components/CheckoutForm.tsx
      purpose: Stripe Elements integration for payment processing
    - path: apps/storefront/src/hooks/useCart.ts
      purpose: Cart state management with Zustand and local storage
    - path: apps/storefront/src/lib/stripe.ts
      purpose: Stripe client configuration and payment utilities
    - path: apps/storefront/src/lib/api.ts
      purpose: API client for storefront-specific endpoints
    - path: apps/api/src/routes/storefront/cart.ts
      purpose: Cart management endpoints (add, remove, sync)
    - path: apps/api/src/routes/storefront/checkout.ts
      purpose: Payment processing and order creation endpoints
    - path: apps/api/src/routes/storefront/comics.ts
      purpose: Public comic listing and detail endpoints
    - path: apps/api/src/webhooks/stripe.ts
      purpose: Stripe webhook handler for payment confirmations
    - path: packages/database/src/queries/commerce.ts
      purpose: Database queries for orders, cart, and payments
    files_to_modify:
    - path: packages/database/src/schema/index.ts
      changes: 'Add commerce tables: orders, order_items, cart_items, payments'
    - path: packages/ui/src/index.ts
      changes: Export new storefront components (ProductCard, CartDrawer, CheckoutForm)
    - path: apps/api/src/routes/index.ts
      changes: 'Add storefront routes: /cart, /checkout, /orders, /comics/public'
    - path: packages/auth/src/middleware.ts
      changes: Add storefront domain to CORS and session handling
  acceptance_criteria:
  - criterion: Storefront displays paginated comic listings with title, creator, price,
      preview thumbnail, and purchase button
    verification: Navigate to /comics and verify at least 10 comics display with all
      required fields and pagination works
  - criterion: Comic detail pages render server-side with full metadata and high-quality
      preview images
    verification: Visit /comics/[id] and verify page source contains meta tags, images
      load progressively, and all comic details display
  - criterion: Shopping cart persists across sessions and syncs with server for authenticated
      users
    verification: Add items to cart, refresh browser, verify cart persists; login
      and verify cart syncs to server
  - criterion: Stripe payment integration completes full purchase flow with digital
      delivery
    verification: Complete test purchase using Stripe test card 4242424242424242,
      verify order confirmation and digital comic access
  - criterion: Search and filtering returns relevant results within 500ms for comic
      discovery
    verification: Use search bar and category filters, verify results accuracy and
      response time under 500ms
  testing:
    unit_tests:
    - file: apps/storefront/src/components/__tests__/ComicCard.test.tsx
      coverage_target: 90%
      scenarios:
      - Comic card displays all required fields
      - Add to cart button triggers correct action
      - Loading states render correctly
    - file: apps/storefront/src/hooks/__tests__/useCart.test.ts
      coverage_target: 85%
      scenarios:
      - Cart state management operations
      - Local storage persistence
      - Server synchronization
    - file: apps/storefront/src/lib/__tests__/stripe-utils.test.ts
      coverage_target: 95%
      scenarios:
      - Payment intent creation
      - Webhook signature verification
      - Error handling for failed payments
    integration_tests:
    - file: apps/storefront/src/__tests__/integration/purchase-flow.test.ts
      scenarios:
      - Complete purchase flow from cart to confirmation
      - Digital delivery after successful payment
      - Cart abandonment and recovery
    - file: apps/storefront/src/__tests__/integration/comic-discovery.test.ts
      scenarios:
      - Search and filter integration with API
      - Pagination with dynamic loading
    manual_testing:
    - step: Test responsive design on mobile, tablet, desktop
      expected: Layout adapts properly across all screen sizes
    - step: Verify SEO meta tags and structured data on product pages
      expected: Google Rich Results Test shows valid product markup
    - step: Test payment flow with various Stripe test cards
      expected: All card scenarios (success, decline, 3DS) handle correctly
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Setup Next.js 16 storefront app with App Router and required dependencies'
      done: false
      ai_friendly: true
    - task: '[AI] Create database schema for commerce tables (orders, cart_items,
        payments)'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design storefront architecture and integration patterns with
        existing Morpheus services'
      done: false
      ai_friendly: false
    - task: '[AI] Implement basic comic listing and detail page components with SSR'
      done: false
      ai_friendly: true
    - task: '[AI] Build cart management system with Zustand and local storage persistence'
      done: false
      ai_friendly: true
    - task: '[AI] Integrate Stripe payment processing with checkout form components'
      done: false
      ai_friendly: true
    - task: '[AI] Create API endpoints for cart, checkout, and public comic access'
      done: false
      ai_friendly: true
    - task: '[AI] Implement search and filtering functionality with server components'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure payment security, webhook validation, and order fulfillment
        logic'
      done: false
      ai_friendly: false
    - task: '[AI] Add comprehensive unit and integration tests for all components'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Review security implementation, test payment flows, and optimize
        performance'
      done: false
      ai_friendly: false
    - task: '[AI] Setup SEO optimization with proper meta tags and structured data'
      done: false
      ai_friendly: true
- key: T86
  title: Cart Management
  type: Feature
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 3
  area: ecommerce
  dependsOn:
  - T85
  agent_notes:
    research_findings: "**Context:**\nCart Management is a critical ecommerce foundation\
      \ for Morpheus's storefront where users can add comic transformations, manage\
      \ quantities, apply discounts, and proceed to checkout. This enables the business\
      \ model by allowing users to purchase multiple comic transformations, bundle\
      \ deals, and subscription plans. Without robust cart functionality, users can\
      \ only make single purchases, limiting revenue potential and user experience.\n\
      \n**Technical Approach:**\n- **State Management**: Use Zustand for client-side\
      \ cart state with persistence to localStorage/sessionStorage\n- **Backend**:\
      \ Fastify routes for cart CRUD operations with PostgreSQL storage for authenticated\
      \ users\n- **Database Schema**:Cart table linking to users, cart_items table\
      \ with product references, quantities, and metadata\n- **Session Handling**:\
      \ Support both guest carts (localStorage) and authenticated user carts (database-backed)\n\
      - **Real-time Sync**: WebSocket or polling to sync cart state across multiple\
      \ tabs/devices\n- **Validation**: Server-side price validation, inventory checks,\
      \ and business rule enforcement\n\n**AI Suitability Analysis:**\n- High AI effectiveness:\
      \ CRUD API endpoints, database migrations, cart state reducers, form validation,\
      \ unit tests, type definitions\n- Medium AI effectiveness: Cart persistence\
      \ logic, checkout flow integration, real-time synchronization, integration tests\n\
      - Low AI effectiveness: Cart abandonment strategies, complex pricing rules architecture,\
      \ performance optimization decisions, security model design\n\n**Dependencies:**\n\
      - External: zustand, react-hook-form, zod (validation), stripe (payment preparation)\n\
      - Internal: User authentication service, Product catalog, Pricing engine, Database\
      \ models, Payment processing foundation\n\n**Risks:**\n- **Race Conditions**:\
      \ Multiple tab updates causing cart conflicts - implement optimistic updates\
      \ with server reconciliation\n- **Cart Abandonment**: Users losing cart data\
      \ - implement robust persistence and recovery mechanisms  \n- **Price Manipulation**:\
      \ Client-side price tampering - always validate pricing server-side\n- **Performance**:\
      \ Large carts causing slow loads - implement pagination and lazy loading for\
      \ cart items\n- **Inventory Sync**: Items becoming unavailable while in cart\
      \ - implement real-time availability checks\n\n**Complexity Notes:**\nInitially\
      \ appears straightforward, but cart management involves complex state synchronization,\
      \ session handling, and business rule validation. AI can accelerate the boilerplate\
      \ significantly (60-70% of code), but architectural decisions around state management\
      \ and real-time sync require human expertise. Expect 40% complexity increase\
      \ due to cross-device synchronization requirements.\n\n**Key Files:**\n- packages/shared/src/types/cart.ts:\
      \ Cart type definitions and schemas\n- apps/api/src/routes/cart/: Cart API endpoints\
      \ (GET, POST, PUT, DELETE)\n- apps/storefront/src/stores/cart-store.ts: Zustand\
      \ cart state management\n- apps/storefront/src/components/cart/: Cart UI components\n\
      - packages/db/src/schema/cart.sql: Database schema for carts and cart_items\n\
      - apps/storefront/src/hooks/use-cart.ts: Cart operations hook\n- apps/api/src/services/cart-service.ts:\
      \ Business logic for cart operations\n"
    design_decisions:
    - decision: Use Zustand with persistence middleware for cart state management
      rationale: Provides simple state management with built-in persistence, TypeScript
        support, and minimal boilerplate. Scales better than useState for complex
        cart operations and integrates well with Next.js SSR.
      alternatives_considered:
      - Redux Toolkit
      - React Context + useReducer
      - TanStack Query only
      ai_implementation_note: AI can generate the entire Zustand store structure,
        actions, and persistence configuration from type definitions
    - decision: Implement hybrid cart storage (localStorage for guests, database for
        authenticated users)
      rationale: Maximizes conversion by not requiring login for cart usage, while
        providing persistent cross-device experience for registered users. Supports
        cart migration on login.
      alternatives_considered:
      - Database only
      - LocalStorage only
      - Session storage only
      ai_implementation_note: AI can generate the synchronization logic and migration
        functions once the storage strategy is defined
    - decision: Server-side cart validation with client-side optimistic updates
      rationale: Ensures data integrity and prevents price manipulation while maintaining
        responsive UX. Critical for payment processing trust and inventory management.
      alternatives_considered:
      - Client-side only validation
      - Server-side only validation
      ai_implementation_note: AI can generate validation schemas, API middleware,
        and rollback logic for failed optimistic updates
    researched_at: '2026-02-08T18:54:29.986565'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:37:21.615041'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 93fc1df4
    planning_hash: 874cb894
  technical_notes:
    approach: 'Implement a dual-layer cart system with Zustand managing client state
      and Fastify APIs handling persistence. Create cart and cart_items tables in
      PostgreSQL with proper indexing. Build REST endpoints for cart operations with
      real-time WebSocket updates for inventory changes. Implement cart migration
      logic for guest-to-authenticated user transitions. Use Zod schemas for validation
      across client/server boundary and implement optimistic updates with server reconciliation
      for responsive UX.

      '
    external_dependencies:
    - name: zustand
      version: ^4.4.0
      reason: Lightweight state management for cart operations with persistence middleware
    - name: zod
      version: ^3.22.0
      reason: Runtime validation for cart items, quantities, and pricing data
    - name: immer
      version: ^10.0.0
      reason: Immutable state updates for complex cart modifications
    - name: '@tanstack/react-query'
      version: ^5.0.0
      reason: Server state synchronization and caching for cart data
    files_to_modify:
    - path: packages/db/src/schema/index.sql
      changes: Add cart and cart_items table definitions with proper indexes
    - path: apps/api/src/routes/index.ts
      changes: Register cart routes with authentication middleware
    - path: apps/storefront/src/app/layout.tsx
      changes: Add CartProvider context wrapper
    new_files:
    - path: packages/shared/src/types/cart.ts
      purpose: TypeScript interfaces and Zod schemas for cart data structures
    - path: packages/db/src/schema/cart.sql
      purpose: PostgreSQL schema for cart and cart_items tables
    - path: apps/api/src/routes/cart/index.ts
      purpose: Express router with cart CRUD endpoints
    - path: apps/api/src/routes/cart/get-cart.ts
      purpose: GET /api/cart - retrieve user's current cart
    - path: apps/api/src/routes/cart/add-item.ts
      purpose: POST /api/cart/items - add item to cart
    - path: apps/api/src/routes/cart/update-item.ts
      purpose: PUT /api/cart/items/:id - update cart item quantity
    - path: apps/api/src/routes/cart/remove-item.ts
      purpose: DELETE /api/cart/items/:id - remove item from cart
    - path: apps/api/src/services/cart-service.ts
      purpose: Business logic for cart operations, validation, migration
    - path: apps/storefront/src/stores/cart-store.ts
      purpose: Zustand store managing client-side cart state
    - path: apps/storefront/src/hooks/use-cart.ts
      purpose: React hook providing cart operations and state
    - path: apps/storefront/src/components/cart/cart-drawer.tsx
      purpose: Slide-out cart UI component
    - path: apps/storefront/src/components/cart/cart-item.tsx
      purpose: Individual cart item display and controls
    - path: apps/storefront/src/components/cart/cart-summary.tsx
      purpose: Cart totals, taxes, discounts summary
    - path: apps/storefront/src/components/cart/add-to-cart-button.tsx
      purpose: Reusable button component for adding products to cart
  acceptance_criteria:
  - criterion: Users can add/remove/update quantities of comic transformations in
      their cart with real-time price updates
    verification: Manual test adding items, changing quantities, removing items -
      verify cart total updates immediately
  - criterion: Cart state persists across browser sessions and syncs between authenticated
      user devices
    verification: Add items to cart, close browser, reopen - items remain. Login from
      different device - cart syncs
  - criterion: Guest carts migrate to user account upon authentication without data
      loss
    verification: Add items as guest, sign up/login - verify all cart items transfer
      to authenticated cart
  - criterion: Cart operations handle concurrent modifications and inventory changes
      gracefully
    verification: Open cart in multiple tabs, modify simultaneously - verify no duplicate
      items or lost updates
  - criterion: All cart operations validate server-side pricing and inventory availability
    verification: Unit tests verify server validation + manual test attempting price
      manipulation fails
  testing:
    unit_tests:
    - file: packages/shared/src/__tests__/cart-types.test.ts
      coverage_target: 90%
      scenarios:
      - Cart schema validation with Zod
      - Cart item calculations
      - Invalid data rejection
    - file: apps/api/src/__tests__/cart-service.test.ts
      coverage_target: 85%
      scenarios:
      - CRUD operations for cart items
      - Guest cart migration logic
      - Inventory validation
      - Price calculation accuracy
      - Concurrent modification handling
    - file: apps/storefront/src/stores/__tests__/cart-store.test.ts
      coverage_target: 85%
      scenarios:
      - Zustand state mutations
      - Optimistic updates
      - LocalStorage persistence
      - Server sync reconciliation
    integration_tests:
    - file: apps/api/src/__tests__/integration/cart-api.test.ts
      scenarios:
      - 'Full cart workflow: add -> update -> checkout'
      - Guest to authenticated user migration
      - Cross-device cart synchronization
      - WebSocket real-time updates
    manual_testing:
    - step: Add multiple comic transformations to cart as guest user
      expected: Items appear in cart with correct prices, quantities, thumbnails
    - step: Sign up/login while cart has items
      expected: All guest cart items seamlessly transfer to user account
    - step: Modify cart in multiple browser tabs simultaneously
      expected: Changes sync across tabs without conflicts or duplicates
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create TypeScript types and Zod schemas in packages/shared/src/types/cart.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Generate PostgreSQL schema for cart tables in packages/db/src/schema/cart.sql'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design cart state management architecture and WebSocket sync
        strategy'
      done: false
      ai_friendly: false
    - task: '[AI] Implement Zustand cart store with persistence in apps/storefront/src/stores/cart-store.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Build Fastify API endpoints for cart CRUD operations in apps/api/src/routes/cart/'
      done: false
      ai_friendly: true
    - task: '[AI] Create cart service layer with business logic in apps/api/src/services/cart-service.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Implement React hook for cart operations in apps/storefront/src/hooks/use-cart.ts'
      done: false
      ai_friendly: true
    - task: '[AI] Build cart UI components (drawer, items, summary) in apps/storefront/src/components/cart/'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Implement guest-to-authenticated migration logic and test edge
        cases'
      done: false
      ai_friendly: false
    - task: '[AI] Generate comprehensive unit tests for all cart functionality'
      done: false
      ai_friendly: true
    - task: '[AI] Write integration tests for cart API endpoints and state sync'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Performance testing and optimization for large cart scenarios'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Security review and final integration testing'
      done: false
      ai_friendly: false
- key: T87
  title: Checkout Flow
  type: Feature
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 5
  area: ecommerce
  dependsOn:
  - T83
  - T86
  agent_notes:
    research_findings: "**Context:**\nThe checkout flow is critical for monetizing\
      \ Morpheus's novel-to-comic transformation service. This enables users to purchase\
      \ generated comics, individual panels, or subscription plans. Given the creative\
      \ nature of the product, the checkout needs to handle both digital downloads\
      \ and physical merchandise, with preview capabilities and licensing options.\
      \ This is essential for the M6 Commerce milestone to establish revenue streams.\n\
      \n**Technical Approach:**\n- Frontend: Next.js App Router with React Server\
      \ Components for cart/checkout pages\n- Payment Processing: Stripe with webhooks\
      \ for secure payment handling\n- Cart State: Zustand for client-side cart management\
      \ + Supabase for persistence\n- Order Management: PostgreSQL schema with order/order_items\
      \ tables\n- File Delivery: Supabase Storage with signed URLs for digital downloads\n\
      - Email: Resend for order confirmations and delivery notifications\n- Validation:\
      \ Zod schemas shared between frontend/backend\n- Security: CSRF protection,\
      \ rate limiting on payment endpoints\n\n**AI Suitability Analysis:**\n- High\
      \ AI effectiveness: Cart CRUD operations, Stripe webhook handlers, order confirmation\
      \ emails, form validation, database migrations, unit tests for payment logic\n\
      - Medium AI effectiveness: Cart state management with Zustand, order status\
      \ tracking components, integration between Stripe and Supabase\n- Low AI effectiveness:\
      \ Payment flow UX decisions, pricing strategy logic, security review of payment\
      \ handlers, complex order state transitions\n\n**Dependencies:**\n- External:\
      \ @stripe/stripe-js, stripe (Node), zustand, @hookform/resolvers, react-hook-form\n\
      - Internal: Existing auth system, product catalog (comics/panels), user dashboard,\
      \ email service setup\n\n**Risks:**\n- Payment security: Ensure no sensitive\
      \ data in frontend, all processing server-side\n- Race conditions: Multiple\
      \ users purchasing limited editions simultaneously  \n- Failed payments: Robust\
      \ webhook handling with retry logic and dead letter queues\n- Cart abandonment:\
      \ Need session persistence without requiring login\n- File delivery: Prevent\
      \ unauthorized access to purchased digital content\n\n**Complexity Notes:**\n\
      More complex than typical e-commerce due to digital asset delivery and creative\
      \ licensing options. AI can accelerate the standard payment flow implementation\
      \ (~60% of work), but business logic around comic licensing and delivery requires\
      \ human design. Expect 2-3 week timeline with AI assistance vs 4-5 weeks manually.\n\
      \n**Key Files:**\n- apps/dashboard/app/(dashboard)/checkout/page.tsx: Main checkout\
      \ interface\n- apps/api/src/routes/orders.ts: Order management endpoints\n-\
      \ apps/api/src/routes/webhooks/stripe.ts: Payment webhook handlers\n- packages/database/migrations:\
      \ Order and cart table schemas  \n- packages/shared/src/schemas/order.ts: Zod\
      \ validation schemas\n- apps/dashboard/lib/stores/cart.ts: Cart state management\n"
    design_decisions:
    - decision: Use Stripe for payment processing with server-side webhook handling
      rationale: Industry standard, excellent TypeScript support, handles PCI compliance,
        supports both one-time and subscription payments needed for Morpheus business
        model
      alternatives_considered:
      - PayPal
      - Square
      - Custom crypto payments
      ai_implementation_note: AI can generate most Stripe integration boilerplate
        including webhook signatures, payment intent creation, and error handling
        patterns
    - decision: Zustand + Supabase hybrid for cart management
      rationale: Zustand provides excellent UX for cart interactions, Supabase persistence
        enables cart recovery and cross-device access without complex session management
      alternatives_considered:
      - Pure localStorage
      - Redux Toolkit
      - React Context only
      ai_implementation_note: AI excellent at generating Zustand stores and Supabase
        CRUD operations, can create cart synchronization logic
    - decision: Separate order fulfillment service for digital delivery
      rationale: Digital comic delivery requires secure file access, download limits,
        and format conversion - better as dedicated service than inline checkout logic
      alternatives_considered:
      - Inline delivery
      - Third-party digital delivery platform
      ai_implementation_note: AI can scaffold the service structure and file access
        patterns, but security policies need human review
    researched_at: '2026-02-08T18:54:59.579010'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:37:52.310167'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 412c4fd0
    planning_hash: ecc04d91
  technical_notes:
    approach: 'Build a multi-step checkout flow with cart management, payment processing,
      and order fulfillment. Frontend uses Next.js with React Server Components for
      cart display and client components for interactive elements. Backend Fastify
      handles order creation, Stripe integration via webhooks for payment processing,
      and secure digital asset delivery through Supabase Storage. Cart state syncs
      between Zustand (client) and Supabase (persistence) for optimal UX.

      '
    external_dependencies:
    - name: '@stripe/stripe-js'
      version: ^2.1.0
      reason: Frontend Stripe integration for payment forms and checkout
    - name: stripe
      version: ^14.0.0
      reason: Server-side Stripe API for payment processing and webhooks
    - name: zustand
      version: ^4.4.0
      reason: Lightweight state management for shopping cart functionality
    - name: react-hook-form
      version: ^7.45.0
      reason: Form handling for checkout with validation and error states
    - name: '@hookform/resolvers'
      version: ^3.3.0
      reason: Zod integration with react-hook-form for type-safe validation
    files_to_modify:
    - path: packages/database/src/schema.ts
      changes: Add orders, order_items, cart_items tables with proper indexes
    - path: apps/dashboard/app/layout.tsx
      changes: Add cart provider and Stripe provider initialization
    - path: apps/api/src/index.ts
      changes: Register order routes and webhook endpoints with rate limiting
    new_files:
    - path: apps/dashboard/app/(dashboard)/cart/page.tsx
      purpose: Cart display with item management and checkout initiation
    - path: apps/dashboard/app/(dashboard)/checkout/page.tsx
      purpose: Multi-step checkout form with Stripe Elements integration
    - path: apps/dashboard/app/(dashboard)/orders/[id]/page.tsx
      purpose: Order confirmation and digital asset download page
    - path: apps/api/src/routes/orders.ts
      purpose: Order CRUD operations, creation, status updates
    - path: apps/api/src/routes/webhooks/stripe.ts
      purpose: Stripe webhook handlers for payment events
    - path: apps/api/src/routes/cart.ts
      purpose: Server-side cart persistence and synchronization
    - path: apps/dashboard/lib/stores/cart.ts
      purpose: Zustand cart state management with Supabase sync
    - path: apps/api/src/services/order-fulfillment.ts
      purpose: Digital asset delivery and order completion logic
    - path: apps/api/src/services/stripe.ts
      purpose: Stripe SDK wrapper with error handling and retries
    - path: packages/shared/src/schemas/order.ts
      purpose: Zod schemas for order validation (frontend/backend shared)
    - path: packages/shared/src/schemas/cart.ts
      purpose: Cart item validation and type definitions
    - path: packages/database/migrations/20241201_create_orders.sql
      purpose: Database schema for orders and order_items tables
    - path: packages/database/migrations/20241201_create_cart.sql
      purpose: Cart persistence table for authenticated users
  acceptance_criteria:
  - criterion: Users can add items to cart, modify quantities, and proceed through
      multi-step checkout
    verification: E2E test flow from product selection  cart  payment  confirmation
      page
  - criterion: Stripe payment processing handles success/failure with webhook confirmation
    verification: Integration test with Stripe test webhooks + manual testing with
      test cards
  - criterion: Digital assets are delivered via secure signed URLs after successful
      payment
    verification: Test order fulfillment - verify download links work and expire appropriately
  - criterion: Cart state persists across sessions and syncs between devices
    verification: Add items, logout/login, verify cart restored + test concurrent
      sessions
  - criterion: Order management system tracks status from pending  paid  fulfilled
    verification: Database queries show correct order state transitions + admin dashboard
      view
  testing:
    unit_tests:
    - file: apps/api/src/__tests__/routes/orders.test.ts
      coverage_target: 90%
      scenarios:
      - Create order with valid items
      - Calculate totals with discounts/tax
      - Handle invalid product IDs
      - Inventory validation
    - file: apps/api/src/__tests__/routes/webhooks/stripe.test.ts
      coverage_target: 95%
      scenarios:
      - Payment success webhook
      - Payment failure handling
      - Duplicate webhook prevention
      - Invalid webhook signatures
    - file: apps/dashboard/lib/stores/__tests__/cart.test.ts
      coverage_target: 85%
      scenarios:
      - Add/remove/update cart items
      - Cart persistence to Supabase
      - Merge cart on login
      - Clear cart after checkout
    integration_tests:
    - file: apps/api/src/__tests__/integration/checkout-flow.test.ts
      scenarios:
      - 'Complete checkout flow: cart  order  payment  fulfillment'
      - Failed payment recovery
      - Concurrent purchase of limited items
    - file: apps/dashboard/__tests__/integration/cart-sync.test.ts
      scenarios:
      - Cart state sync between Zustand and Supabase
      - Guest cart migration to authenticated user
    manual_testing:
    - step: Test Stripe payment with test card 4242424242424242
      expected: Payment succeeds, webhook fires, order status updates to 'paid'
    - step: Attempt to purchase sold-out limited edition comic
      expected: Error message displayed, payment prevented
    - step: Download purchased digital comic after payment
      expected: Signed URL works, file downloads successfully
  estimates:
    development: 8
    code_review: 1.5
    testing: 2
    documentation: 0.5
    total: 12
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database migration files for orders, order_items, and cart_items
        tables'
      done: false
      ai_friendly: true
    - task: '[AI] Generate Zod schemas for order and cart validation in packages/shared'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design checkout UX flow and payment form layout decisions'
      done: false
      ai_friendly: false
    - task: '[AI] Implement Zustand cart store with add/remove/update operations'
      done: false
      ai_friendly: true
    - task: '[AI] Create Fastify order routes with CRUD operations and validation'
      done: false
      ai_friendly: true
    - task: '[AI] Build Stripe webhook handlers with idempotency and error handling'
      done: false
      ai_friendly: true
    - task: '[AI] Implement cart persistence service syncing Zustand to Supabase'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Configure Stripe webhook endpoints and test payment flows'
      done: false
      ai_friendly: false
    - task: '[AI] Create order fulfillment service for digital asset delivery'
      done: false
      ai_friendly: true
    - task: '[AI] Build Next.js checkout pages with React Server Components'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit tests for all payment and cart logic'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Security review of payment handlers and webhook validation'
      done: false
      ai_friendly: false
    - task: '[AI] Write integration tests for complete checkout flow'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Manual testing with Stripe test cards and edge cases'
      done: false
      ai_friendly: false
- key: T88
  title: Order Management
  type: Feature
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p0
  effort: 3
  area: ecommerce
  dependsOn:
  - T87
  agent_notes:
    research_findings: '**Context:**

      Order Management is the foundational system for the Morpheus commerce platform,
      handling the complete lifecycle of customer orders from creation to fulfillment.
      This encompasses order creation when customers purchase novel-to-comic transformations,
      payment processing, order status tracking, inventory management for digital
      assets, fulfillment workflows, and customer communication. The business value
      includes revenue capture, customer satisfaction through order transparency,
      operational efficiency for order processing, and data insights for business
      analytics.


      **Technical Approach:**

      Implement a robust order management system using event-driven architecture with
      PostgreSQL for ACID transactions, Redis for caching and session management,
      and Supabase real-time subscriptions for order status updates. Use the Repository
      pattern for data access, Command/Query Responsibility Segregation (CQRS) for
      complex order operations, and state machines for order status transitions. Integrate
      with Stripe for payment processing, implement webhook handlers for payment confirmations,
      and use background job processing with Bull/BullMQ for async operations like
      email notifications and order fulfillment.


      **AI Suitability Analysis:**

      - High AI effectiveness: Database schema generation, CRUD operations, API endpoint
      boilerplate, test fixtures, validation schemas, webhook handler templates, email
      notification templates, order status enum definitions

      - Medium AI effectiveness: State machine logic implementation, payment integration
      code, order calculation business logic, API integration patterns, error handling
      middleware

      - Low AI effectiveness: Order state transition rules design, payment security
      considerations, order fulfillment workflow architecture, complex refund/cancellation
      policies, performance optimization strategies


      **Dependencies:**

      - External: stripe (payment processing), bull/bullmq (job queues), node-cron
      (scheduled tasks), decimal.js (precise calculations), joi/zod (validation),
      nodemailer (email notifications)

      - Internal: authentication service, user management, product catalog, notification
      system, audit logging, file storage service for order attachments


      **Risks:**

      - Payment security vulnerabilities: Implement proper webhook signature verification,
      use environment variables for sensitive keys, follow PCI compliance guidelines

      - Race conditions in order updates: Use database transactions, implement optimistic
      locking, add proper error handling for concurrent modifications

      - Order state inconsistencies: Design clear state transition rules, implement
      compensating actions, add comprehensive audit trails

      - Performance issues with order queries: Implement proper indexing, use pagination,
      consider read replicas for reporting queries


      **Complexity Notes:**

      This task is significantly more complex than initially estimated due to the
      interconnected nature of order management with payments, inventory, notifications,
      and customer communication. However, AI assistance can accelerate development
      by 40-50% through automated generation of boilerplate code, test cases, and
      standard CRUD operations. The main complexity lies in designing robust state
      transitions and handling edge cases in payment processing.


      **Key Files:**

      - apps/backend/src/modules/orders/: New module directory with controllers, services,
      repositories

      - apps/backend/src/database/migrations/: Order-related table schemas

      - packages/shared/src/types/order.ts: Shared TypeScript interfaces

      - apps/dashboard/src/pages/orders/: Admin order management UI

      - apps/storefront/src/components/checkout/: Customer-facing order creation

      '
    design_decisions:
    - decision: Use PostgreSQL with JSONB for order metadata and separate tables for
        core order data
      rationale: Provides ACID compliance for financial data while allowing flexibility
        for varying order attributes across different product types
      alternatives_considered:
      - Document database for flexibility
      - Pure relational schema
      - Event sourcing pattern
      ai_implementation_note: AI can generate table schemas, migrations, and TypeScript
        types automatically from business requirements
    - decision: Implement finite state machine for order status management
      rationale: Ensures valid state transitions, prevents invalid order states, and
        provides clear audit trail for order lifecycle
      alternatives_considered:
      - Simple status enum
      - Event-driven status updates
      - Workflow orchestration
      ai_implementation_note: AI can generate state machine boilerplate and transition
        validation logic once states and rules are defined
    - decision: Use Stripe webhooks for payment confirmation rather than polling
      rationale: Real-time payment updates, reduced API calls, better user experience,
        and reliable payment state synchronization
      alternatives_considered:
      - Payment status polling
      - Client-side payment confirmation
      - Hybrid approach
      ai_implementation_note: AI can generate webhook handlers, signature verification,
        and idempotency logic following Stripe documentation
    researched_at: '2026-02-08T18:55:27.850626'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:38:31.044675'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: e89f3ee4
    planning_hash: 09c8b5ac
  technical_notes:
    approach: 'Implement a layered architecture with order controllers handling HTTP
      requests, order services managing business logic, and repositories handling
      data persistence. Use event-driven patterns for order state changes to trigger
      notifications, inventory updates, and audit logging. Implement background job
      processing for async operations like email sending and fulfillment workflows.
      Design RESTful APIs for order CRUD operations with proper pagination, filtering,
      and sorting capabilities.

      '
    external_dependencies:
    - name: stripe
      version: ^14.0.0
      reason: Payment processing and webhook handling for order transactions
    - name: bullmq
      version: ^4.0.0
      reason: Background job processing for order fulfillment and notifications
    - name: decimal.js
      version: ^10.4.0
      reason: Precise decimal arithmetic for financial calculations
    - name: joi
      version: ^17.0.0
      reason: Request validation for order creation and updates
    - name: ioredis
      version: ^5.0.0
      reason: Redis client for caching and session management
    files_to_modify:
    - path: apps/backend/src/app.ts
      changes: Add order routes to Express app, register webhook endpoints
    - path: apps/backend/src/database/database.ts
      changes: Register new order-related repositories
    - path: packages/shared/src/types/index.ts
      changes: Export order types for frontend usage
    - path: apps/dashboard/src/routes.tsx
      changes: Add order management route definitions
    - path: apps/storefront/src/lib/api.ts
      changes: Add order creation and status API calls
    new_files:
    - path: apps/backend/src/modules/orders/order.entity.ts
      purpose: TypeORM entity for orders table with relationships
    - path: apps/backend/src/modules/orders/order-item.entity.ts
      purpose: TypeORM entity for order items with product references
    - path: apps/backend/src/modules/orders/order.repository.ts
      purpose: Data access layer for order CRUD operations
    - path: apps/backend/src/modules/orders/order.service.ts
      purpose: Business logic for order management and calculations
    - path: apps/backend/src/modules/orders/order.controller.ts
      purpose: REST API endpoints for order operations
    - path: apps/backend/src/modules/orders/order-state-machine.ts
      purpose: State machine for order status transitions
    - path: apps/backend/src/modules/payments/stripe.service.ts
      purpose: Stripe payment processing integration
    - path: apps/backend/src/modules/payments/webhook.controller.ts
      purpose: Handle Stripe webhook events
    - path: apps/backend/src/jobs/order-notification.job.ts
      purpose: Background job for sending order status emails
    - path: apps/backend/src/jobs/order-fulfillment.job.ts
      purpose: Background job for processing order fulfillment
    - path: apps/backend/src/database/migrations/20241201000001-create-orders.ts
      purpose: Database migration for orders table
    - path: apps/backend/src/database/migrations/20241201000002-create-order-items.ts
      purpose: Database migration for order_items table
    - path: packages/shared/src/types/order.ts
      purpose: TypeScript interfaces for order-related data structures
    - path: packages/shared/src/types/payment.ts
      purpose: TypeScript interfaces for payment-related data structures
    - path: apps/dashboard/src/pages/orders/OrdersListPage.tsx
      purpose: Admin page for viewing and managing orders
    - path: apps/dashboard/src/pages/orders/OrderDetailPage.tsx
      purpose: Admin page for viewing single order details
    - path: apps/dashboard/src/components/orders/OrdersTable.tsx
      purpose: Table component for displaying orders list
    - path: apps/dashboard/src/components/orders/OrderStatusBadge.tsx
      purpose: Component for displaying order status with styling
    - path: apps/storefront/src/components/checkout/CheckoutForm.tsx
      purpose: Customer checkout form with Stripe integration
    - path: apps/storefront/src/components/checkout/OrderSummary.tsx
      purpose: Order summary component for checkout process
    - path: apps/storefront/src/pages/orders/OrderStatusPage.tsx
      purpose: Customer order tracking page
    - path: apps/backend/src/config/stripe.config.ts
      purpose: Stripe configuration and environment variables
    - path: apps/backend/src/config/jobs.config.ts
      purpose: Bull/BullMQ job queue configuration
  acceptance_criteria:
  - criterion: Order creation API accepts product selection, customer info, and returns
      order with unique ID and 'pending' status
    verification: POST /api/orders with valid payload returns 201 with order object
      containing id, status='pending', items, total_amount
  - criterion: Payment processing integration with Stripe creates payment intent and
      updates order status based on payment result
    verification: Stripe webhook handler updates order status to 'confirmed' on payment
      success, 'failed' on payment failure
  - criterion: 'Order state transitions follow business rules: pendingconfirmedprocessingfulfilled
      or pendingfailedcancelled'
    verification: State machine prevents invalid transitions, audit log records all
      status changes with timestamps
  - criterion: Admin dashboard displays orders with filtering, pagination, and bulk
      actions for order management
    verification: Dashboard loads orders list with search/filter by status/date, supports
      50+ orders per page, bulk status updates
  - criterion: Real-time order status updates notify customers and admins through
      WebSocket connections
    verification: Order status change triggers real-time update in customer account
      and admin dashboard within 2 seconds
  testing:
    unit_tests:
    - file: apps/backend/src/modules/orders/__tests__/order.service.test.ts
      coverage_target: 90%
      scenarios:
      - Order creation with valid data
      - Order calculation with multiple items
      - Order state transitions
      - Payment processing workflows
      - Validation error handling
    - file: apps/backend/src/modules/orders/__tests__/order.repository.test.ts
      coverage_target: 85%
      scenarios:
      - CRUD operations
      - Query filtering and pagination
      - Transaction handling
    - file: apps/backend/src/modules/orders/__tests__/order-state-machine.test.ts
      coverage_target: 95%
      scenarios:
      - Valid state transitions
      - Invalid state transition prevention
      - State change event emission
    integration_tests:
    - file: apps/backend/src/__tests__/integration/orders-api.test.ts
      scenarios:
      - Complete order creation flow with payment
      - Order status updates via webhooks
      - Admin order management operations
    - file: apps/backend/src/__tests__/integration/stripe-webhooks.test.ts
      scenarios:
      - Payment success webhook processing
      - Payment failure webhook handling
      - Webhook signature verification
    e2e_tests:
    - file: apps/web/__tests__/e2e/order-checkout.spec.ts
      scenarios:
      - Customer completes full checkout process
      - Order status updates in customer dashboard
      - Admin processes order fulfillment
    manual_testing:
    - step: Create order through storefront checkout
      expected: Order appears in admin dashboard with pending status
    - step: Process Stripe test payment
      expected: Order status updates to confirmed in real-time
    - step: Test webhook failure scenarios
      expected: Error handling and retry mechanisms function correctly
  estimates:
    development: 5
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 8
    ai_acceleration_factor: 0.55
  progress:
    status: not-started
    checklist:
    - task: '[AI] Generate database migration files for orders and order_items tables
        with proper relationships and indexes'
      done: false
      ai_friendly: true
    - task: '[AI] Create TypeORM entities for Order and OrderItem with validation
        decorators and relationships'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design order state machine transitions and business rules for
        status changes'
      done: false
      ai_friendly: false
    - task: '[AI] Implement order repository with CRUD operations, filtering, and
        pagination methods'
      done: false
      ai_friendly: true
    - task: '[AI] Create order service with business logic for calculations, validations,
        and state management'
      done: false
      ai_friendly: true
    - task: '[AI] Build REST API controllers with proper request/response handling
        and error management'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Integrate Stripe payment processing with proper security measures
        and webhook verification'
      done: false
      ai_friendly: false
    - task: '[AI] Implement background job processors for email notifications and
        order fulfillment'
      done: false
      ai_friendly: true
    - task: '[AI] Create React components for admin dashboard order management with
        table, filters, and actions'
      done: false
      ai_friendly: true
    - task: '[AI] Build customer-facing checkout flow with Stripe Elements integration'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit tests for services, repositories, and
        state machine logic'
      done: false
      ai_friendly: true
    - task: '[AI] Create integration tests for API endpoints and payment webhook processing'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Review security implementation, test payment flows, and validate
        business logic'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Performance testing with order queries, optimize database indexes
        and caching'
      done: false
      ai_friendly: false
    - task: '[AI] Generate API documentation and implementation guides'
      done: false
      ai_friendly: true
- key: T89
  title: Inventory Tracking
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 2
  area: ecommerce
  dependsOn:
  - T88
  agent_notes:
    research_findings: '**Context:**

      Inventory tracking is essential for the Morpheus comic marketplace to manage
      digital and physical comic assets. This system needs to track comic availability,
      manage stock levels for physical products, handle reservations during checkout
      processes, and provide real-time inventory data to both the storefront and admin
      dashboard. For a novel-to-comic platform, this includes tracking generated comic
      pages, print quantities, and digital distribution rights.


      **Technical Approach:**

      Implement event-driven inventory management using PostgreSQL with row-level
      security, Redis for caching, and WebSocket connections for real-time updates.
      Use Supabase''s real-time subscriptions for inventory state changes. Design
      around ACID transactions for stock adjustments and implement optimistic concurrency
      control for high-traffic scenarios. Follow CQRS pattern separating read/write
      operations for performance.


      **AI Suitability Analysis:**

      - High AI effectiveness: Database schema generation, CRUD API endpoints, validation
      schemas, unit tests, inventory adjustment utilities, webhook handlers

      - Medium AI effectiveness: Real-time subscription setup, Redis integration patterns,
      transaction management logic, API integration with existing services

      - Low AI effectiveness: Inventory strategy decisions (FIFO/LIFO), concurrency
      control architecture, business rule definitions for stock allocation


      **Dependencies:**

      - External: ioredis (Redis client), @supabase/realtime-js, decimal.js (precise
      calculations), node-cron (cleanup jobs)

      - Internal: Authentication service, Order management system, Payment processing,
      Admin dashboard components, Storefront product displays


      **Risks:**

      - Race conditions in stock updates: Use database-level locks and atomic transactions

      - Cache inconsistency: Implement cache invalidation strategies and eventual
      consistency patterns

      - Performance with high concurrency: Use Redis for hot inventory data and database
      connection pooling

      - Overselling scenarios: Implement reservation system with timeout mechanisms


      **Complexity Notes:**

      Medium complexity task that benefits significantly from AI assistance. The bulk
      of CRUD operations, schema definitions, and test coverage can be AI-generated.
      Human oversight needed for transaction boundaries and concurrency patterns.
      AI can accelerate development by 60-70% on this task.


      **Key Files:**

      - packages/api/src/routes/inventory.ts: Main inventory API routes

      - packages/database/migrations/: Inventory tables and indexes

      - packages/shared/types/inventory.ts: TypeScript definitions

      - apps/admin/components/inventory/: Dashboard inventory management

      - apps/storefront/components/product/: Stock display components

      '
    design_decisions:
    - decision: Event-sourced inventory with Redis caching layer
      rationale: Provides audit trail, handles high read loads, enables real-time
        updates across multiple frontend instances
      alternatives_considered:
      - Simple database-only approach
      - Third-party inventory service
      - In-memory state management
      ai_implementation_note: AI can generate event handlers, cache update patterns,
        and Redis pub/sub implementations following provided examples
    - decision: Reservation-based stock allocation during checkout
      rationale: Prevents overselling while allowing cart abandonment without permanent
        stock reduction
      alternatives_considered:
      - Immediate stock deduction
      - Queue-based allocation
      - Probabilistic availability
      ai_implementation_note: AI can implement timeout mechanisms, cleanup jobs, and
        reservation state machines based on specifications
    - decision: Separate inventory contexts for digital vs physical products
      rationale: Digital comics have unlimited stock but need license tracking, physical
        products need traditional inventory management
      alternatives_considered:
      - Unified inventory model
      - Completely separate systems
      - Product-type inheritance
      ai_implementation_note: AI can generate polymorphic schemas and context-specific
        business logic following established patterns
    researched_at: '2026-02-08T18:55:54.060535'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:39:01.259946'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: df96eac8
    planning_hash: f134ed6a
  technical_notes:
    approach: 'Create inventory microservice within the Fastify API using PostgreSQL
      for persistence and Redis for caching/real-time data. Implement inventory adjustments
      through event sourcing with Supabase real-time subscriptions pushing updates
      to frontends. Use atomic transactions for stock operations and implement reservation
      system for checkout flows. Build admin interfaces for inventory management and
      integrate stock displays into storefront product pages.

      '
    external_dependencies:
    - name: ioredis
      version: ^5.3.0
      reason: High-performance Redis client for caching and pub/sub
    - name: decimal.js
      version: ^10.4.0
      reason: Precise decimal arithmetic for inventory calculations
    - name: node-cron
      version: ^3.0.0
      reason: Scheduled cleanup of expired reservations and inventory audits
    - name: '@supabase/realtime-js'
      version: ^2.9.0
      reason: Real-time inventory updates across client applications
    files_to_modify:
    - path: packages/api/src/app.ts
      changes: Register inventory routes and WebSocket handlers
    - path: packages/shared/types/index.ts
      changes: Export inventory types for cross-package usage
    - path: apps/admin/src/app/layout.tsx
      changes: Add inventory management navigation link
    - path: apps/storefront/components/product/ProductCard.tsx
      changes: Integrate stock status display and real-time updates
    new_files:
    - path: packages/database/migrations/20241201000000_create_inventory_tables.sql
      purpose: Database schema for inventory, stock_adjustments, reservations tables
    - path: packages/api/src/routes/inventory.ts
      purpose: Main inventory API endpoints with CRUD operations
    - path: packages/api/src/services/inventory-service.ts
      purpose: Core business logic for inventory management and calculations
    - path: packages/api/src/services/reservation-service.ts
      purpose: Handle checkout reservations with timeout mechanisms
    - path: packages/api/src/middleware/inventory-realtime.ts
      purpose: WebSocket middleware for real-time inventory updates
    - path: packages/shared/types/inventory.ts
      purpose: TypeScript interfaces for inventory entities and DTOs
    - path: packages/shared/schemas/inventory.ts
      purpose: Zod validation schemas for API requests
    - path: apps/admin/components/inventory/InventoryDashboard.tsx
      purpose: Main admin interface for inventory overview
    - path: apps/admin/components/inventory/StockAdjustmentForm.tsx
      purpose: Form component for manual stock adjustments
    - path: apps/admin/components/inventory/InventoryTable.tsx
      purpose: Tabular display of all inventory items with actions
    - path: apps/storefront/components/product/StockIndicator.tsx
      purpose: Real-time stock status display for products
    - path: apps/storefront/hooks/useInventorySubscription.ts
      purpose: React hook for subscribing to inventory updates
    - path: packages/api/src/utils/inventory-calculations.ts
      purpose: Utility functions for stock math and business rules
  acceptance_criteria:
  - criterion: Real-time inventory tracking with automatic stock updates
    verification: Test stock adjustment API endpoints and verify WebSocket updates
      reach connected clients within 500ms
  - criterion: Atomic reservation system prevents overselling during checkout
    verification: Concurrent checkout test with 100 simultaneous requests for same
      item with stock=1 results in exactly 1 successful reservation
  - criterion: Admin dashboard displays accurate inventory levels with management
      controls
    verification: 'Manual verification: stock adjustments in admin panel immediately
      reflect in storefront and database queries'
  - criterion: 'Performance requirements: <200ms API response for inventory queries'
    verification: Load test inventory GET endpoints with 1000 concurrent requests,
      measure 95th percentile response time
  - criterion: Complete audit trail for all inventory movements
    verification: Database query shows all stock changes with timestamps, reasons,
      and user attribution in inventory_transactions table
  testing:
    unit_tests:
    - file: packages/api/src/__tests__/inventory/inventory-service.test.ts
      coverage_target: 90%
      scenarios:
      - Stock adjustment calculations
      - Reservation creation and expiration
      - Inventory validation rules
      - Cache invalidation logic
      - Error handling for insufficient stock
    - file: packages/api/src/__tests__/inventory/inventory-routes.test.ts
      coverage_target: 85%
      scenarios:
      - CRUD operations on inventory items
      - Authentication and authorization checks
      - Input validation and sanitization
      - Rate limiting behavior
    integration_tests:
    - file: packages/api/src/__tests__/integration/inventory-flow.test.ts
      scenarios:
      - End-to-end checkout reservation flow
      - Real-time updates through WebSocket
      - Database transaction rollback scenarios
      - Redis cache consistency with PostgreSQL
      - Concurrent stock adjustment handling
    manual_testing:
    - step: Create product with stock=5 in admin dashboard
      expected: Product appears in storefront with 'In Stock' status
    - step: Simulate 10 concurrent purchases of same item
      expected: Only 5 succeed, others show 'Out of Stock' error
    - step: Adjust inventory in admin while user viewing product
      expected: Stock level updates in real-time without page refresh
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database migration files for inventory tables with proper
        indexes and constraints'
      done: false
      ai_friendly: true
    - task: '[AI] Generate TypeScript types and Zod schemas for inventory entities'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design inventory reservation strategy and timeout policies'
      done: false
      ai_friendly: false
    - task: '[AI] Implement core inventory service with CRUD operations and stock
        calculations'
      done: false
      ai_friendly: true
    - task: '[AI] Build Fastify routes with authentication, validation, and error
        handling'
      done: false
      ai_friendly: true
    - task: '[AI] Create Redis caching layer with invalidation strategies'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Implement atomic transaction boundaries for stock adjustments'
      done: false
      ai_friendly: false
    - task: '[AI] Setup Supabase real-time subscriptions and WebSocket handlers'
      done: false
      ai_friendly: true
    - task: '[AI] Build admin dashboard components with forms and tables'
      done: false
      ai_friendly: true
    - task: '[AI] Create storefront inventory integration with real-time updates'
      done: false
      ai_friendly: true
    - task: '[AI] Generate comprehensive unit tests for services and routes'
      done: false
      ai_friendly: true
    - task: '[AI] Write integration tests for end-to-end inventory flows'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Performance testing and concurrency validation'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Code review focusing on transaction safety and business logic'
      done: false
      ai_friendly: false
- key: T90
  title: Fulfillment Integration
  type: Task
  milestone: M6 - Commerce & Distribution
  iteration: I6
  priority: p1
  effort: 3
  area: ecommerce
  dependsOn:
  - T88
  agent_notes:
    research_findings: '**Context:**

      Fulfillment integration is critical for the comic book marketplace, enabling
      automated order processing, inventory management, and shipping coordination.
      This connects the Morpheus storefront to fulfillment providers (like print-on-demand
      services for physical comics, digital delivery systems, or third-party logistics).
      Without this, orders would require manual processing, creating bottlenecks and
      poor customer experience. This is essential for M6 Commerce & Distribution milestone
      completion.


      **Technical Approach:**

      Implement a fulfillment service layer using the Strategy pattern to support
      multiple providers (Printful, Gooten, Lulu for physical; SendOwl, Gumroad for
      digital). Use webhook handlers for status updates, queue-based processing with
      BullMQ for reliability, and PostgreSQL for order/fulfillment state management.
      Follow event-driven architecture with domain events for order lifecycle changes.


      **AI Suitability Analysis:**

      - High AI effectiveness: Webhook handlers, CRUD operations for orders/fulfillment
      records, API client boilerplate, validation schemas, unit tests, database migrations

      - Medium AI effectiveness: Strategy pattern implementation, error handling patterns,
      queue job processors, integration adapters

      - Low AI effectiveness: Provider selection logic, business rules for fulfillment
      routing, error recovery strategies, pricing calculations


      **Dependencies:**

      - External: axios/fetch for API calls, @bull-board/fastify for queue monitoring,
      zod for validation, stripe webhooks integration

      - Internal: Order management system, user authentication, payment processing,
      product catalog, notification service


      **Risks:**

      - Provider API changes: Implement adapter pattern with versioning, comprehensive
      error handling

      - Order state synchronization: Use eventual consistency with compensating transactions,
      implement idempotency

      - Webhook security: Verify signatures, implement replay protection, rate limiting

      - Performance bottlenecks: Queue-based processing, database indexing, caching
      fulfillment status


      **Complexity Notes:**

      More complex than initially estimated due to multiple provider integrations
      and state management complexity. AI can significantly accelerate implementation
      of API clients and handlers, but business logic requires careful human design.
      Queue implementation and webhook handling are well-suited for AI assistance.


      **Key Files:**

      - apps/api/src/services/fulfillment/: Core fulfillment service and strategies

      - apps/api/src/routes/webhooks/fulfillment.ts: Webhook endpoints

      - apps/api/src/jobs/fulfillment.ts: Queue job processors

      - packages/database/migrations/: Order fulfillment tables

      - apps/dashboard/src/components/orders/: Order management UI

      '
    design_decisions:
    - decision: Use Strategy pattern for multiple fulfillment providers
      rationale: Enables easy addition of new providers without code changes, promotes
        testability, and separates provider-specific logic
      alternatives_considered:
      - Single provider hardcoded
      - Plugin architecture
      - Factory pattern
      ai_implementation_note: AI can generate provider adapter boilerplate and interface
        implementations efficiently
    - decision: Queue-based processing with BullMQ
      rationale: Ensures reliable order processing, handles provider API failures
        gracefully, enables retry mechanisms and monitoring
      alternatives_considered:
      - Synchronous processing
      - Custom queue implementation
      - AWS SQS
      ai_implementation_note: AI excellent for generating job processors, error handling,
        and queue configuration
    - decision: Event-driven architecture for order lifecycle
      rationale: Decouples fulfillment from order processing, enables multiple subscribers
        (notifications, analytics), improves scalability
      alternatives_considered:
      - Direct service calls
      - Database triggers
      - Message broker
      ai_implementation_note: AI can generate event handlers and subscription logic
        effectively
    researched_at: '2026-02-08T18:56:17.718757'
    researched_by: research-agent-claude-sonnet-4
    planned_at: '2026-02-08T19:39:29.181532'
    planned_by: planning-agent-claude-sonnet-4
    content_hash: 29a43bdf
    planning_hash: e3c12fb5
  technical_notes:
    approach: "Implement a fulfillment service layer using Strategy pattern for multiple\
      \ providers (print-on-demand, digital delivery). \nUse BullMQ for reliable queue-based\
      \ order processing with webhook handlers for status updates. \nStore fulfillment\
      \ state in PostgreSQL with proper indexing for order tracking. \nImplement event-driven\
      \ architecture for order lifecycle notifications. \nCreate dashboard UI for\
      \ order management and fulfillment monitoring.\n"
    external_dependencies:
    - name: bullmq
      version: ^5.0.0
      reason: Reliable queue processing for fulfillment jobs
    - name: '@bull-board/api'
      version: ^5.0.0
      reason: Queue monitoring dashboard
    - name: '@bull-board/fastify'
      version: ^5.0.0
      reason: Fastify integration for queue monitoring
    - name: ioredis
      version: ^5.3.0
      reason: Redis client for BullMQ backend
    - name: crypto
      version: builtin
      reason: Webhook signature verification
    files_to_modify:
    - path: apps/api/src/app.ts
      changes: Register fulfillment routes and initialize queue processors
    - path: packages/database/src/schema/orders.ts
      changes: Add fulfillment_status, provider_id, tracking_info columns
    - path: apps/dashboard/src/pages/orders/index.tsx
      changes: Add fulfillment status column and tracking info display
    new_files:
    - path: apps/api/src/services/fulfillment/fulfillment-service.ts
      purpose: Core orchestration service implementing Strategy pattern
    - path: apps/api/src/services/fulfillment/providers/base-provider.ts
      purpose: Abstract base class for fulfillment providers
    - path: apps/api/src/services/fulfillment/providers/printful.ts
      purpose: Printful API integration for physical products
    - path: apps/api/src/services/fulfillment/providers/sendowl.ts
      purpose: SendOwl integration for digital products
    - path: apps/api/src/routes/webhooks/fulfillment.ts
      purpose: Webhook endpoints for all provider status updates
    - path: apps/api/src/jobs/fulfillment.ts
      purpose: BullMQ job processors for order fulfillment tasks
    - path: apps/api/src/types/fulfillment.ts
      purpose: TypeScript interfaces for fulfillment domain objects
    - path: packages/database/migrations/20241201000000_fulfillment.sql
      purpose: Database schema for fulfillment tracking tables
    - path: apps/dashboard/src/components/orders/fulfillment-status.tsx
      purpose: React component for displaying fulfillment status and tracking
    - path: apps/api/src/config/providers.ts
      purpose: Configuration for fulfillment provider credentials and settings
  acceptance_criteria:
  - criterion: System successfully processes orders through multiple fulfillment providers
      (Printful, SendOwl) with proper state transitions
    verification: Run integration test suite and verify orders move from 'pending'
      -> 'processing' -> 'fulfilled' with provider webhooks
  - criterion: Webhook handlers securely process fulfillment status updates with signature
      verification and idempotency
    verification: Test webhook endpoints with provider test payloads, verify signature
      validation and duplicate request handling
  - criterion: Queue-based order processing handles failures gracefully with retry
      logic and dead letter queue
    verification: Simulate provider API failures, verify BullMQ retry attempts and
      failed job monitoring in dashboard
  - criterion: Dashboard displays real-time order status and fulfillment tracking
      for store administrators
    verification: Place test orders, verify UI updates reflect fulfillment status
      changes within 30 seconds
  - criterion: System maintains data consistency between order state and fulfillment
      provider state
    verification: Run data integrity checks comparing local order status with provider
      API responses
  testing:
    unit_tests:
    - file: apps/api/src/services/fulfillment/__tests__/fulfillment-service.test.ts
      coverage_target: 90%
      scenarios:
      - Order creation with different product types
      - Provider strategy selection logic
      - Error handling for provider API failures
      - State transition validation
    - file: apps/api/src/services/fulfillment/__tests__/providers/printful.test.ts
      coverage_target: 85%
      scenarios:
      - API client request/response handling
      - Webhook payload parsing
      - Rate limiting and retry logic
    - file: apps/api/src/jobs/__tests__/fulfillment.test.ts
      coverage_target: 85%
      scenarios:
      - Queue job processing success
      - Job failure and retry mechanisms
      - Dead letter queue handling
    integration_tests:
    - file: apps/api/src/__tests__/integration/fulfillment-flow.test.ts
      scenarios:
      - Complete order fulfillment workflow
      - Multi-provider order handling
      - Webhook to queue to database flow
    manual_testing:
    - step: Create physical comic order in dashboard
      expected: Order appears in Printful dashboard within 2 minutes
    - step: Trigger fulfillment webhook manually
      expected: Order status updates in Morpheus dashboard
    - step: Monitor BullMQ dashboard during high load
      expected: Jobs process without memory leaks or timeouts
  estimates:
    development: 4
    code_review: 1
    testing: 1.5
    documentation: 0.5
    total: 7
    ai_acceleration_factor: 0.65
  progress:
    status: not-started
    checklist:
    - task: '[AI] Create database migration for fulfillment tables with proper indexes'
      done: false
      ai_friendly: true
    - task: '[AI] Implement TypeScript types and Zod validation schemas for fulfillment
        objects'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Design fulfillment provider selection strategy and business rules'
      done: false
      ai_friendly: false
    - task: '[AI] Implement base provider abstract class and Printful/SendOwl concrete
        implementations'
      done: false
      ai_friendly: true
    - task: '[AI] Create webhook handlers with signature verification and payload
        parsing'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Implement complex business logic for order state transitions
        and error recovery'
      done: false
      ai_friendly: false
    - task: '[AI] Set up BullMQ job processors with retry logic and monitoring'
      done: false
      ai_friendly: true
    - task: '[AI] Build dashboard UI components for order management and fulfillment
        tracking'
      done: false
      ai_friendly: true
    - task: '[AI] Write comprehensive unit tests for all service classes and API clients'
      done: false
      ai_friendly: true
    - task: '[HUMAN] Integration testing with real provider sandbox environments'
      done: false
      ai_friendly: false
    - task: '[HUMAN] Security review of webhook endpoints and API key management'
      done: false
      ai_friendly: false
    - task: '[AI] Generate API documentation and deployment configuration'
      done: false
      ai_friendly: true
